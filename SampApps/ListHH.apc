{Application 'ListHH' logic file generated by CSPro }
PROC GLOBAL

  numeric wcluster, i, counthh, countent;
  numeric ngps = 0, templat = 0, templon = 0, tempalt = 0;
  numeric xlatitude, xlongitude, xaltitude;
  alpha(1) latpole;
  alpha(1) lngpole;
  
  string line1;

PROC FL_CNULL
preproc
  { get language from calling menu }
  SetLanguage( GetLanguage() );

  wcluster = tonumber( sysparm()[1:4] );
  counthh   = 0;        { total household counter }

  YCLUSTER = wcluster;
  if !loadcase( CLUSTERS, YCLUSTER ) then
    errmsg( 60000, YCLUSTER );
    stop(1);
  endif;

  { set the name for the HTML file }
  HTML_InitAlign();
  HTMLname = "ListHH.HTML";
  if FileExist( HTMLname ) then
    FileDelete( HTMLname )
  endif;
  setfile( HTMLFile, HTMLname, create );

  { initialize the report headings }
  zstring1 = MakeText( tr("Households Eligible for Selection for Cluster: %04d"), wcluster );
  zstring2 = MakeText( tr("Date: %s"), edit("9999/99/99", SysDate("YYYYMMDD")));
  CellValues(1) = tr("HH");
  CellValues(2) = tr("Structure");
  CellValues(3) = tr("Household address");
  CellValues(4) = tr("Head of household");
  CellValues(5) = tr("Observations");
  { specify columns that are left aligned, strings are left aligned }
  CellAlign(1) = 3;  // column 3 is household address 
  CellAlign(2) = 4;  // column 4 head of household
  CellAlign(3) = 5;  // column 5 observations
  HTML_Header( CellAlign, zstring1 );  // generates a general HTML header
  HTML_BeginTable( CellValues, zstring2, 5 );  // generates the HTML table script with the column headers

  while loadcase( HHLISTING ) do
    for i in RECORD2 do
      if !LINTRO in "8","9" then
        { populates the elements of a row based on household information }
		if LTRUEHH = 1 then
          CellValues(1) = edit("9999", LNUMBER);
		else
          CellValues(1) = "BLANK";
		endif;
        CellValues(2) = edit("9999", LSTRUCT) + "-" + edit("999",LHOUSEH);
        CellValues(3) = strip(LADDRESS);
        CellValues(4) = strip(LNAME);
        CellValues(5) = strip(LNOTES);
        HTML_OneRow( CellValues, 5 );   // generates the HTML script for a row with relevant household data
        countent = countent + 1;
        if LNUMBER(i) <> notappl then
          counthh  = counthh + 1;
        endif;
        { accumulate household coordinates to average them at the cluster level }
        if LALTITUDE(i) <> notappl & LLONGITUDE(i) <> notappl & LLATITUDE(i) <> notappl then
          ngps  = ngps + 1;
          templat = templat + LLATITUDE(i);
          templon = templon + LLONGITUDE(i);
          tempalt = tempalt + LALTITUDE(i);
          if ngps = 1 then
	        latpole = LLATPOLE(i);
		    lngpole = LLNGPOLE(i);
		  endif;
        endif;
      endif;
    enddo;
    HTML_EndTable();
    { heading for report with FileWrite command }
    HTML_Paragraph( " " );
    line1 = maketext( tr("Households expected in cluster %d, total entries in roster %d households listed %d"), LSEGHH, countent, counthh );
    HTML_ParagraphS( line1 );
  enddo;
 
  { Cluster segmentation report }
  SCLUSTER = wcluster;
  if loadcase( SEGMENT_DCT, SCLUSTER ) then
    zstring2 = tr("Cluster Segmentation");
    CellValues(1) = tr("Segment");
    CellValues(2) = tr("Households");
    CellValues(3) = tr("Cummulative");
    CellValues(4) = tr("Percent");
    HTML_Paragraph( " " );
    HTML_Paragraph( " " );
    HTML_BeginTable( CellValues, zstring2, 4 );  // generates the HTML table script with the column headers
    for i in SEGMENT_DCT.SEGREC2 do
      CellValues(1) = edit("99", SEGNUM);
      CellValues(2) = edit("Z99", SHHNUMB);
      CellValues(3) = edit("ZZ99",SCUMMUL);
      CellValues(4) = edit("Z99.9",SPERCENT);
      HTML_OneRow( CellValues, 4 );   // generates the HTML script for a row with relevant household data
    enddo;
    HTML_EndTable();
    HTML_Paragraph( " " );
    line1 = maketext(tr("Segment selected %d, Number of households in selected segment %d"), SSEGNUM, SSEGHH);
    HTML_ParagraphS( line1 );
  endif;
 
  {{GPS}
  { !!! Report coordinates when collected at cluster level }
  GCLUSTER = wcluster;
  if loadcase( GPS_DCT, GCLUSTER ) & GLATITUDE(1) <> notappl then
    zstring2 = tr("Cluster Coordinates");
    CellValues(1) = tr("Reading");
    CellValues(2) = tr("Latitude");
    CellValues(3) = tr("Longitude");
    CellValues(4) = tr("Altitude");
    CellValues(5) = tr("Satellites");
    CellValues(6) = tr("Accuraccy");
    HTML_Paragraph( " " );
    HTML_Paragraph( " " );
    HTML_BeginTable( CellValues, zstring2, 6 );  // generates the HTML table script with the column headers
    for i in GPS_DCT.GPSSEC do
      if GLATITUDE <> notappl then
        CellValues(1) = edit("9", i);
        CellValues(2) = GLATPOLE + edit("ZZZ9.999", GLATITUDE);
        CellValues(3) = GLNGPOLE + edit("ZZZ9.999", GLONGITUDE);
        CellValues(4) = edit("ZZZ9",GALTITUDE);
        CellValues(5) = edit("Z9",GSATELLIT);
        CellValues(6) = edit("Z9",GACCURACY);
        HTML_OneRow( CellValues, 6 );   // generates the HTML script for a row with relevant household data
      endif;
    enddo;
    HTML_EndTable();
  endif;
  {GPS}}
  {+GPS}
  { !!! Report coordinates when collected at household level }
  if ngps > 0 then
    xlatitude  = templat / ngps;
    xlongitude = templon / ngps;
    xaltitude  = tempalt / ngps;
    zstring2 = tr("Cluster coordinates based on average from households");
    CellValues(1) = tr("Households");
    CellValues(2) = tr("Latitude");
    CellValues(3) = tr("Longitude");
    CellValues(4) = tr("Altitude");
    HTML_Paragraph( " " );
    HTML_Paragraph( " " );
    HTML_BeginTable( CellValues, zstring2, 4 );  // generates the HTML table script with the column headers
    CellValues(1) = edit("ZZ9", ngps);
    CellValues(2) = latpole + edit("ZZZ9.999", xlatitude);
    CellValues(3) = lngpole + edit("ZZZ9.999", xlongitude);
    CellValues(4) = edit("ZZZ9",xaltitude);
    HTML_OneRow( CellValues, 4 );   // generates the HTML script for a row with relevant household data
    HTML_EndTable();
  else
    errmsg( 61000, wcluster );
  endif;
  {GPS+}
  HTML_End();
  view( "file://" + pathname(application) +  HTMLName );
  stop(1);
