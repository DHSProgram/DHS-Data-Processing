PROC GLOBAL

  { Exports asset data for wealth index and generates the wealth index starter program - Trevor Croft. February 9, 2017 - DHS7 }
  { Update 5/17/2022 by Trevor Croft to drop animals and landarea for urban PCA, and domestic everywhere. AH106 also excluded from PCA. }
  string Name = "Your name";	{ adjust Name, Country, SType, Year !!! }
  string Country = "Country";
  string SType = "DHS";
  string Year = "2020-21";

  { Things to check in the application:
  0.  Set Country and Year above
  1.  Coding of maid/domestic (default = 51) for occupations in A908, A913, AM604 - not used any more 5/17/2022
  2.  Coding of not related (default = 11) for relationship code in AH03
  3.  Coding of no facility (default = 61) for toilet facility in AH109
  4.  Coding of AH131 (land), particularly if various units are used
  5.  Ownership of land if collected in individual questionnaires
  6.  Ownership of house if collected in individual questionnaires
  7.  Variables to exclude from Principal Component Analysis
      see excludedvars - those not considered assets (e.g. exclude mosquito net variables, handwashing variables, "shocks", etc.)
  8.  Exclude alpha variables
  }
  { set to the code used in the occupation variables for maids or domestic workers - !!!}
  numeric maid_code = 51;
  { set to the code used in the relationship variables for not related - !!!}
  numeric not_related = 11;
  { set to the code used for no facility for the toilet facility for AH109 - !!!}
  numeric no_facility = 61;

  numeric i, n, v;
  array nvstr(2) = 0,0;
  numeric exvar = 0, vlabs = 0;
  numeric inDataList = 0;			{ Whether the lines from the .SPS file exported are from the Data List }
  numeric inVarLabels = 0;			{ Whether the lines from the .SPS file exported are from the Variable Labels }
  numeric inValueLabels = 0;		{ Whether the lines from the .SPS file exported are from the Value Labels }
  numeric inMissingValues = 0;		{ Whether the lines from the .SPS file exported are from the Missing Values }
  numeric nVars = 0;				{ Number of variables in .SPS }

  string VarName;					{ Current variable name }
  string VarLabel;					{ Label of current variable }

  array string VarNames(500);		{ Array of all variable names }
  array string VarLabels(500);		{ Array of variable labels }
  array string Exclude_VarNames(100);	{ List of variable names to exclude from output lists }

  file wealth_assets;				{ File for exported asset variables }
  file spss_code;					{ File for .SPS code generated by export }
  file spss_inc;					{ File for modified .SPS with spaces added where necessary to avoid errors as an include file }
  file wealth_code;					{ File for SPSS code for calculating the wealth index }

  string pathn;					    { Path name of the directory in which the wealth code is being run }
  string fname;					    { Name of exported .SPS file }
  string spss_text, trim_text;	    { Buffer for lines from the .SPS file and a trimmed version of that line }

  array code(50);					{ Array of codes from value labels }
  array string labels(50);			{ Array of labels from value labels }
  array string varstrings(50,2);	{ Array of strings for outputting lists of variables for wealth index code (,1) for common PCA and (,2) for additional vars }
  string newstr;

  { Creates list of variables to exclude from outputted list of variables for wealth index }
  function excludevar(exv, string vname);
    inc(exv);
    Exclude_VarNames(exv) = vname;
    excludevar = exv;
  end;

  { Sets variables to exclude from outputted list of variables for wealth index - add other excluded variables here !!!}
  function excludedvars();
    numeric x = 0;
    x = excludevar(x,"AHREGION");	{ Region }
    x = excludevar(x,"AHTYPE");		{ Urban/rural }
    x = excludevar(x,"AH102");		{ Source of water for cooking/handwashing }
    x = excludevar(x,"AH103");		{ Location of water source }
    x = excludevar(x,"AH104");		{ Time to water source and back }
    x = excludevar(x,"AH105");		{ line number of HH member who collected the water }
	x = excludevar(x,"AH106");      { Household did not have sufficient amount of water }
    x = excludevar(x,"AH107");		{ Do anything to water to make safe to drink }
    x = excludevar(x,"AH108");		{ Water treatment }
    x = excludevar(x,"AH110");		{ Share toilet facilities }
    x = excludevar(x,"AH111");		{ Number of households shared with }
    x = excludevar(x,"AH112");		{ Location of toilet facility }
    x = excludevar(x,"AH114");		{ Septic tank/latrine ever emptied }
    x = excludevar(x,"AH115");		{ Last time septic tank/latrine emptied by service provider }
    x = excludevar(x,"AH116");		{ Place where contents of septic tank/latrine were emptied }
    x = excludevar(x,"AH118");		{ Stove has a chimney }
    x = excludevar(x,"AH119");		{ Stove has a fan }
    x = excludevar(x,"AH121");		{ Food cooked in the house }
    x = excludevar(x,"AH122");		{ Household has separate kitchen }
    x = excludevar(x,"AH124");		{ Heating system has a chimney }
    x = excludevar(x,"AH127");		{ Number of rooms used for sleeping - members per room handled elsewhere }
    x = excludevar(x,"AH128");		{ Own any livestock }
    x = excludevar(x,"AH130");		{ Own land used for agriculture - land handled elsewhere }
    x = excludevar(x,"AH131U");		{ Units for landarea - multiple units }
    x = excludevar(x,"AH133B");		{ Own mobile phone - MobPhone handled elsewhere }
    x = excludevar(x,"AH134");		{ Possession of bank account - CheckAcc handled elsewhere }
    x = excludevar(x,"AH135");		{ Used mobile phone for financial transaction - MobPhone handled elsewhere }
    x = excludevar(x,"AH136");		{ Frequency of smoking in house }
    x = excludevar(x,"AH137");		{ Mosquito net used while sleeping }
    x = excludevar(x,"AH138");		{ Number of mosquito nets }
    x = excludevar(x,"AH149");		{ Place for handwashing }
    x = excludevar(x,"AH150");		{ Presence of water observed }
    x = excludevar(x,"AH151");		{ Presence of soap, ash observed }
    x = excludevar(x,"AH155");		{ Test salt for iodine }
    x = excludevar(x,"AH156");		{ Time of end of household interview }
    x = excludevar(x,"AH156H");		{ Time of end of household interview - hour }
    x = excludevar(x,"AH156M");		{ Time of end of household interview - minutes }
    exvar = x;
  end;

  { Tests whether a variable is to be excluded from list of outputted variables for wealth index }
  function excluded(string vname);
    numeric x;
    excluded = 0;
    do x = 1 while x <= exvar
      if Exclude_VarNames(x) = vname then
        excluded = 1;
        break;
      endif;
    enddo;
  end;

  { Finds the first blank in a string }
  function findblank(string stringvar);
    numeric b;
    { find first blank }
    do b = 1 while b <= length(stringvar) & stringvar[b:1] <> " " enddo;
    findblank = b;
  end;

  { Finds the first non-blank in a string }
  function findnonblank(string stringvar);
    numeric b;
    { find first non blank }
    do b = 1 while b <= length(stringvar) & stringvar[b:1] = " " enddo;
    findnonblank = b;
  end;

  { Removes leading and trailing spaces from a string }
  function string trim(string stringvar);
    numeric b;
    { find first non-blank }
    b = findnonblank(stringvar);
    { return string minus the blanks on the front }
    trim = stringvar[b:length(stringvar)-b+1];
  end;

  { Gets a variable name from a line from the .SPS file exported }
  function string getName(string stringvar);
    numeric x,y;
    x = findnonblank(stringvar);
    y = findblank(stringvar[x:length(stringvar)-x+1]);
    getName = stringvar[x:y-1];
  end;

  { Gets a variable label from a line from the .SPS file exported }
  function string getVarLabel(string stringvar);
    numeric x,y,z;
    x = findnonblank(stringvar);
    y = findblank(stringvar[x:length(stringvar)-x+1]);
    z = findnonblank(stringvar[x+y-1:length(stringvar)-x-y]);
    getVarLabel = stringvar[x+y+z-1:length(stringvar)-x-y-z+1];
  end;

  { Find a variable name in the array of variable names and returns the index number of the variable in the array }
  function findVar(string Var);
    do i = 1 while i <= nVars
      if Var = VarNames(i) then
        break
      endif;
    enddo;
    if i > nVars then i = 0 endif;
    findVar = i;
  end;

  function major_grp(string xlabel)
    { Assuming it is a major group label if the label starts with "---" }
  	major_grp = (xlabel[1:3] = "---");
  end;

  function initnewstr(x);
  { initialize next string. x = 1 for Common list, 2 for Additional list }
    inc(nvstr(x));
    varstrings(nvstr(x),x) = "";
  end;

  { Adds a variable name to the array of strings of variables to be output for the wealth index }
  function addtovarstr(string newvar, x);
    if nvstr(x) = 0 | length(varstrings(nvstr(x),x)) > 150 then initnewstr(x) endif;
    varstrings(nvstr(x),x) = maketext("%s %s",varstrings(nvstr(x),x),newvar);
  end;

  { Removed the path from the data file path and file name }
  function string strip_path(string stext);
    numeric si, s1, s2, l;
    l  = length(stext);
    s1 = pos("'",stext);
    if s1 then
      s2 = pos("'",stext[s1+1:l]);
    endif;
    { if no quote, assume that the whole string is the path and filename }
    if !s2 then s2 = l+1 endif;
    { find last \ in filename, working backwards from the end of the filename }
    do si = s2-1 while si > s1 & stext[si:1] <> "\" by (-1)
    enddo;
    if si > s1 then
      stext = stext[1:s1] + stext[si+1:l-si];
    endif;
    strip_path = stext;
  end;

  { Output SPSS variable creation commands based on SPSS syntax file }
  function flushvar();
    if !excluded(varname) then
      numeric x;

      { Label for the variable }
      VarLabel = Varlabels(FindVar(VarName));

      { Yes/No variable }
      if (vlabs = 2 & code(1) = 1 & code(2) = 2) | (vlabs = 3 & code(1) = 1 & code(2) = 2 & code(3) >= 8) then
        { Already dichotomous - just recode 2 (and special values) to 0 }
        filewrite(wealth_code, "* %s.", varlabel);
        filewrite(wealth_code, "no2zero %s.",varname);
        addtovarstr(varname,1);

      elseif vlabs = 2 & ((code(1) = 0 & code(2) = 1) | (code(1) = 1 & code(2) = 0)) then
        { Already a dichotomous 0/1 variable - do nothing }
        addtovarstr(varname,1);

      elseif pos(varname[1:length("AH129A")-1],"AH129A") then  { animal variables - need binning } { check naming here !!!}
        filewrite(wealth_code, "");
        filewrite(wealth_code, "* %s.", Varlabel);
        filewrite(wealth_code, "if (missing(%s) | AH128 <> 1) %s=0.", varname, varname);
        filewrite(wealth_code, "missing values %s (99).", varname);
        // No longer including 0 animals as an asset TC 1/28/17.
        filewrite(wealth_code, "compute %s_1 = (%s >= 1 & %s <= 4).",   varname, varname, varname);
        filewrite(wealth_code, "compute %s_2 = (%s >= 5 & %s <= 9).",   varname, varname, varname);
        filewrite(wealth_code, "compute %s_3 = (%s >= 10 & %s <= 98).", varname, varname, varname);
        filewrite(wealth_code, "variable labels %s_1 '%s: 1-4' /%s_2 '%s: 5-9' /%s_3 '%s: 10+'.",
          varname, Varlabel, varname, Varlabel, varname, Varlabel);
        if length(varstrings(nvstr(2),2)) > 50 then initnewstr(2); endif;
        // No longer including 0 animals as an asset TC 1/28/17.
        addtovarstr(maketext("%s_%1d", varname,1),2);
        addtovarstr(maketext("%s_%1d", varname,2),2);
        addtovarstr(maketext("%s_%1d", varname,3),2);
        filewrite(wealth_code, "");

      elseif strip(varname) = "AH131" then  { land variable - needs recoding } { This code is for a single unit version !!! }
        filewrite(wealth_code, "");
        filewrite(wealth_code, "* %s.", Varlabel);
        filewrite(wealth_code, "compute landarea = AH131.");
        filewrite(wealth_code, "if (missing(AH131) | AH131 >= 99.8) landarea = 99.9.");
        filewrite(wealth_code, "if (missing(AH130) | AH130 <> 1) landarea=0.");
        filewrite(wealth_code, "missing values landarea (99.9).");
        filewrite(wealth_code, "");
        filewrite(wealth_code, "");
        addtovarstr("landarea",2);

      elseif strip(varname) = "AH131N" then  { land variable - needs recoding } { This code is for a multiple unit version !!! }
        filewrite(wealth_code, "");
        filewrite(wealth_code, "* %s.", Varlabel);
        filewrite(wealth_code, "compute landarea = 0.");
        { add in code here for recoding if there are different land area units - use lowest common denominator unit (e.g. sq. meters) - example below from Cambodia 2014 }
        filewrite(wealth_code, "if (AH131U = 1) landarea = AH131N.       /* sq. meters */");
        filewrite(wealth_code, "if (AH131U = 2) landarea = AH131N*  100. /* Are     =   100 sq. meters */");
        filewrite(wealth_code, "if (AH131U = 3) landarea = AH131N*10000. /* Hectare = 10000 sq. meters */");
        filewrite(wealth_code, "if (AH131U = 4) landarea = AH131N* 1600. /* Rai     =  1600 sq. meters */");
        filewrite(wealth_code, "if (AH131U = 5) landarea = AH131N* 1000. /* Kong    =  1000 sq. meters */");
        { end of coding for different units }
        filewrite(wealth_code, "if (AH131U = 9 and AH131N = 9999.5) landarea = 950000."); 	{ Set to a maximum realistic value !!! Check this carefully !!! Adjust appropriately }
        filewrite(wealth_code, "if (AH131U >= 8) landarea = 0.");
        filewrite(wealth_code, "if (missing(AH131N) | AH131N >= 9999.8) landarea=999999.");
        filewrite(wealth_code, "if (missing(AH130 ) | AH130 <> 1) landarea=0.");
        filewrite(wealth_code, "missing values landarea (999999).");
        filewrite(wealth_code, "");
        filewrite(wealth_code, "");
        addtovarstr("landarea",2);

      elseif vlabs in 1,2 then
        { Either dichotomous or they are specials labels for continuous variables - don't try anything with these }
        addtovarstr(varname,1);

      elseif vlabs >= 3 then

        if vlabs >= 6 & length(varstrings(nvstr(1),1)) > 20 then initnewstr(1); endif;
        filewrite(wealth_code, "");
        filewrite(wealth_code, "* %s.", Varlabel);
        do x = 1 while x <= vlabs
		  { Need to exclude the major groups for variables with major group labels }
		  if !major_grp(labels(x)) then
            filewrite(wealth_code, 'dichotomize (%s=%1d) %s_%1d "%s: %s".',
              varname, code(x), varname, code(x), Varlabel, labels(x));
            addtovarstr(maketext("%s_%1d",strip(varname),code(x)),1);
		  endif;
        enddo;
        filewrite(wealth_code, "");

        { Handle shared toilet facilities }
        if strip(varname) = "AH109" then
          initnewstr(1);
          do x = 1 while x <= vlabs
            if code(x) <> no_facility & !major_grp(labels(x)) then { No facility can not be shared. Also exclude the major group categories }
              filewrite(wealth_code, 'shared_fac %s_%1d %s_%1d_sh "%s: %s - shared".',
                varname, code(x), varname, code(x), Varlabel, labels(x));
              addtovarstr(maketext("%s_%1d_sh", varname,code(x)),1);
            endif;
          enddo;
          filewrite(wealth_code, "");
        endif;

        if vlabs >= 6 & length(varstrings(nvstr(1),1)) > 20 then initnewstr(1); endif;

      endif;
    endif;
  end;

  { Outputs the list of variables for the wealth index to the wealth index code file }
  function output_varlist(ix);
    numeric x;
    { output Common list of variables }
    do x = 1 while x <= nvstr(1)
      filewrite(wealth_code, " %s", varstrings(x,1));
    enddo;
    { output additional list of variables, if needed }
    if ix = 2 then
      do x = 1 while x <= nvstr(2)
        filewrite(wealth_code, " %s", varstrings(x,2));
      enddo;
    endif;
  end;

  function addplus(string xstring);
    { ignore first two characters, but replace all blanks with plus sign }
    numeric x;
    do x = 2 while x <= length(xstring)
      if xstring[x:1] = " " then xstring[x:1] = "+" endif;
    enddo;
    { add a final plus to the end of the string }
    xstring[x:1] = "+";
    newstr = xstring;
  end;

  { Outputs the list of variables for the wealth index to the wealth index code file }
  function output_ctablist();
    numeric x;
    { output Common list of variables }
    do x = 1 while x <= nvstr(1)
      addplus(varstrings(x,1));
      filewrite(wealth_code, " %s", newstr);
    enddo;
    { output additional list of variables }
    do x = 1 while x <= nvstr(2)
      addplus(varstrings(x,2));
      if x = nvstr(2) then { Remove final plus sign } newstr[length(newstr):1] = " " endif;
      filewrite(wealth_code, " %s", newstr);
    enddo;
  end;

  {------------------------------------------------------------------ }
  { Read and output SPSS commands based on generated SPSS syntax file }
  function process_spss();
    numeric b,nb,l;
    excludedvars();
    { Read each record from the SPSS file }
    while fileread(spss_code, spss_text) do

      { first output the spss to a temp file ensuring that a blank is added on all lines that are not commands or terminators of commands }
      if spss_text[1:1] <> " " then
        { Check for the SPSS commands - each string should be 14 characters }
        if spss_text[1:14] in "DATA LIST FILE" then
          { Strip the path from the filename }
          spss_text = strip_path(spss_text);
        elseif spss_text[1:14] in "VARIABLE LABEL","VALUE LABELS  ","MISSING VALUE ","EXECUTE.      " | spss_text[1:1] = "." then
          { Command or terminator - do nothing }
        else
          spss_text = " " + spss_text;
        endif;
      endif;
      filewrite(spss_inc, "%s", spss_text);

      { trim the text to get rid of leading spaces }
      spss_text = trim(spss_text);

      if pos(".", spss_text[1:1]) then { End of Command }
        if inValueLabels then
          flushvar();
        endif;
        inDataList = 0;
        inVarLabels = 0;
        inValueLabels = 0;
        inMissingValues = 0;
      endif;

      if inDataList then { If we are in the Data List, create a list of each variable }
        if !pos("/", spss_text[1:1]) then
          { Add variable to list }
          nVars = nVars + 1;
          VarNames(nVars) = getName(spss_text);
        endif;

      elseif inVarLabels then { If we are in the Var Labels, get the label for each variable }
        l = 1 + pos("/", spss_text[1:1]);  { Position of start of variable name }
        VarName = getName(spss_text[l:length(spss_text)-l+1]);
        v = FindVar(VarName);
        VarLabels(v) = getVarLabel(spss_text[l:length(spss_text)-l+1]);

      elseif inValueLabels then { If we are in the Value Labels, process each variable }
        if pos(getName(spss_text)[1:1],"1234567890") then { numeric value label }
          vlabs = vlabs + 1;
          b = findblank(spss_text);
          code(vlabs) = tonumber(spss_text[1:b-1]);
          nb = findnonblank(spss_text[b:length(spss_text)-b+1]);
          labels(vlabs) = spss_text[b+nb:length(spss_text)-b-nb];

        elseif getName(spss_text)[1:1] = '"' | getName(spss_text)[1:1] = "'" then { alphabetic value label }
          { ignore these }

        else { must be the variable name }
          flushvar();
          { Process the variable }
          l = 1 + pos("/", spss_text[1:1]);  { Position of start of variable name }
          VarName = getName(spss_text[l:length(spss_text)-l+1]);
          vlabs = 0;
        endif;

      elseif inMissingValues then { If we are in the Missing Values, do nothing }

      else { If not in the Data List, Variable Labels, Value Labels, or Missing Values check for the start of one of them }

        if pos("DATA LIST", spss_text) then { Start of Data List }
          inDataList = 1;
        elseif pos("VARIABLE LABELS", spss_text) then { Start of Variable Labels }
          inVarLabels = 1;
        elseif pos("VALUE LABELS", spss_text) then { Start of Value Labels }
          inValueLabels = 1;
        elseif pos("MISSING VALUES", spss_text) then { Start of Missing Values }
          inMissingValues = 1;
        endif;

      endif;
    { write(spss_text); }
    enddo;

  end;

  { Generate the code for running a factor analysis }
  function factor_code( string flabel, string fvname, string fvar);
    filewrite(wealth_code, "*** %s Factor Analysis.", flabel);
    filewrite(wealth_code, "filter off.");
    if length(strip(fvname)) then { for filtering if needed }
      filewrite(wealth_code, "filter by %s.", fvname);
    endif;
    filewrite(wealth_code, "execute.");
    filewrite(wealth_code, "");

    // ix changed to exclude excludes agricultural animal vars and landarea for Urban as well as Common - 5/17/2022
    numeric ix = 2; if flabel in "Common","Urban" then ix = 1 endif;  { Full list of variables or only those for "Common" or "Urban" PCA - excludes agricultural animal vars and landarea }
    filewrite(wealth_code, "factor /variables");
    output_varlist(ix);
    filewrite(wealth_code, "  /missing meansub");
    filewrite(wealth_code, "  /analysis");
    output_varlist(ix);
    filewrite(wealth_code, "  /print univariate initial extraction fscore");
    filewrite(wealth_code, "  /criteria factors(1) iterate(25)");
    filewrite(wealth_code, "  /extraction pc");
    filewrite(wealth_code, "  /rotation norotate");
    if length(strip(fvar)) then {to save the first factor - if needed }
      filewrite(wealth_code, "  /save reg(ALL %s)", fvar);
    endif;
    filewrite(wealth_code, "  /method=correlation.");
    filewrite(wealth_code, "");
  { Means no longer produced for all PCAs - only at the very end.
    { means of the factor by each variable used }
    if length(strip(fvar)) then
      filewrite(wealth_code, "means %s1 by ", fvar);
      output_varlist(ix);
      filewrite(wealth_code, ".");
      filewrite(wealth_code, "");
    endif;
  }
    filewrite(wealth_code, "");
  end;

  { Generate the code for graphing the urban or rural score against the common score to identify issues }
  function graph_code(string res, string res_var);
    res_var = res_var+'score';
	res[1:1] = toupper(res[1:1]); // make first letter upper case
    filewrite(wealth_code, '* Graph %s score by Common score.', res);
    filewrite(wealth_code, 'GGRAPH');
    filewrite(wealth_code, '  /GRAPHDATASET NAME="graphdataset" VARIABLES=comscore %s MISSING=LISTWISE REPORTMISSING=NO', res_var);
    filewrite(wealth_code, '  /GRAPHSPEC SOURCE=INLINE.');
    filewrite(wealth_code, 'BEGIN GPL');
    filewrite(wealth_code, '  SOURCE: s=userSource(id("graphdataset"))');
    filewrite(wealth_code, '  DATA: comscore=col(source(s), name("comscore"))');
    filewrite(wealth_code, '  DATA: %s=col(source(s), name("%s"))', res_var, res_var);
    filewrite(wealth_code, '  GUIDE: axis(dim(1), label("Common wealth score"))'); 
    filewrite(wealth_code, '  GUIDE: axis(dim(2), label("%s wealth score"))', res);
    filewrite(wealth_code, '  ELEMENT: point(position(comscore*%s))', res_var);
    filewrite(wealth_code, 'END GPL.');
  end;

  { Generate the code for running the regressions for urban and rural areas }
  function regress_code(string res, string res_var);
    filewrite(wealth_code, "* Calculate regressions.");
    filewrite(wealth_code, "** Area=%s.", res);
    filewrite(wealth_code, "filter off.");
    filewrite(wealth_code, "filter by %s.", res);
    filewrite(wealth_code, "execute.");
    filewrite(wealth_code, "");
	graph_code(res, res_var);
    filewrite(wealth_code, "");
    filewrite(wealth_code, "* Declare a dataset to be written to in the regression.");
    filewrite(wealth_code, "dataset declare %scorv.", res);
    filewrite(wealth_code, "* Run regression of comscore with %sscore.", res_var);
    filewrite(wealth_code, "regression");
    filewrite(wealth_code, "  /missing listwise");
    filewrite(wealth_code, "  /statistics coeff outs R anova");
    filewrite(wealth_code, "  /criteria=pin(.05) pout(.10)");
    filewrite(wealth_code, "  /noorigin");
    filewrite(wealth_code, "  /dependent comscore");
    filewrite(wealth_code, "  /method=enter %sscore", res_var);
    filewrite(wealth_code, "  /outfile=corv(%scorv).", res);
    filewrite(wealth_code, "");
    filewrite(wealth_code, "* Activate file of output from regression.");
    filewrite(wealth_code, "dataset activate %scorv.", res);
    filewrite(wealth_code, "* Drop all rows of output except the coefficients.");
    filewrite(wealth_code, "select if (rowtype_ = 'EST').");
    filewrite(wealth_code, "execute.");
    filewrite(wealth_code, "* Delete unnecessary variables before merging.");
    filewrite(wealth_code, "delete variables DEPVAR_ VARNAME_.");
    filewrite(wealth_code, "* Rename variables containing the constant and the coefficient.");
    filewrite(wealth_code, "rename variables CONST_=%sconst %sscore=%scoeff.", res_var, res_var, res_var);
    filewrite(wealth_code, "");
    filewrite(wealth_code, "* Re-activate the main household data.");
    filewrite(wealth_code, "dataset activate assets.");
    filewrite(wealth_code, "* merge the coefficients.");
    filewrite(wealth_code, "match files /file = *");
    filewrite(wealth_code, "  /table = %scorv", res);
    filewrite(wealth_code, "  /by ROWTYPE_.");
    filewrite(wealth_code, "execute.");
    filewrite(wealth_code, "");
    filewrite(wealth_code, "");
  end;

  { Generate the code for running histograms of the combined score and another score for each group }
  function freq_code(string res, string res_var);
    filewrite(wealth_code, "filter off.");
    if length(strip(res)) then
      filewrite(wealth_code, "filter by %s.", res);
    endif;
    filewrite(wealth_code, "execute.");
    filewrite(wealth_code, "");
    filewrite(wealth_code, "frequencies variables=combscor %sscore", res_var);
    filewrite(wealth_code, "  /format=notable");
    filewrite(wealth_code, "  /ntiles=5");
    filewrite(wealth_code, "  /statistics=minimum maximum stddev mean");
    filewrite(wealth_code, "  /histogram normal");
    filewrite(wealth_code, "  /order=analysis.");
    filewrite(wealth_code, "");
  end;

  { Generate the code for ranking into quintiles }
  function rank_code(string res, string res_var);
    filewrite(wealth_code, "filter off.");
    if length(strip(res)) then
      filewrite(wealth_code, "filter by %s.", res);
    endif;
    filewrite(wealth_code, "execute.");
    filewrite(wealth_code, "");
    filewrite(wealth_code, "rank variables=%s (A) /rank /ntiles (5) /print=yes /ties=mean.", res_var);
    filewrite(wealth_code, "");
  end;

  {------------------------------------------------------------------ }
  { Main function to generate the SPSS code for the wealth index - calls all of the functions above }
  function create_spss();
    { create the SPSS filename to read from }
    numeric l;
    fname = fname[1:length(fname)-4] + ".sps";
    errmsg("Filename: %s", fname);

    { Set the name of the SPSS file and open the file }
    if setfile(spss_code, fname) then

      { Set the name of the temp SPSS include file }
      if !setfile(spss_inc, fname + ".tmp", create) then
        errmsg("Failed to open %s.tmp", fname);
      endif;

      { Set the name of the Wealth Index starter SPSS file }
      if !setfile(wealth_code, "wealth_index_start.sps", create) then
        errmsg("Failed to open wealth_index_start.sps");
      endif;

      { Path and include files }
      filewrite(wealth_code, "* Wealth index calculation. %s, %s. %s %s %s.", name, edit("99/99/9999",sysdate("mmddyyyy")), Country, SType, Year);
      pathn = pathname(application);
      l = length(strip(pathn));
      if pathn[l:1] = "\" then pathn[l:1] = " " endif;
      filewrite(wealth_code, "cd '%s'.", pathn);
      filewrite(wealth_code, "include file='%s'.", strip_path(fname));
      filewrite(wealth_code, "missing values AH131 (99.9).");   { Check missing value for AH131.  Drop if AH131 is not included in dataset !!!}
      filewrite(wealth_code, "execute.");
      filewrite(wealth_code, "set tvars=both.");
      filewrite(wealth_code, "");

      { Macro defintions }
      filewrite(wealth_code, "* Macro definitions to perform some recoding automatically.");
      filewrite(wealth_code, "* Note: Do not use an asterisk in front of a macro name to try to comment it out - it will run any way because of the way the macros are expanded.");
      filewrite(wealth_code, "* Delete the line instead or change the spelling of the macro in the comment.");
      filewrite(wealth_code, "* Do not use the names of macros in comments - they will also be expanded too, and likely will fail.");
      filewrite(wealth_code, "");

      { Macro - dichotomize }
      filewrite(wealth_code, "*{Create binary variables based on condition and give label }.");
      filewrite(wealth_code, "define dichotomize( !positional !enclose('(',')') / !positional !tokens(1) / !positional !tokens(1) )");
      filewrite(wealth_code, "compute !2=0.");
      filewrite(wealth_code, "if (!1) !2=1.");
      filewrite(wealth_code, "variable labels !2 !3.");
      filewrite(wealth_code, "value labels !2 0 'No' 1 'Yes'.");
      filewrite(wealth_code, "formats !2 (f1.0).");
      filewrite(wealth_code, "!enddefine.");
      filewrite(wealth_code, "");

      { Macro - shared_fac (for shared toilet facilities) }
      filewrite(wealth_code, "*(Separate shared toilets from non-shared toilets).");
      filewrite(wealth_code, "define shared_fac( !positional !tokens(1) / !positional !tokens(1) / !positional !tokens(1) ).");
      filewrite(wealth_code, "compute !2 = 0.");
      filewrite(wealth_code, "do if (AH110=1).");
      filewrite(wealth_code, "+ if (!1=1) !2 = 1.");
      filewrite(wealth_code, "+ compute !1 = 0.");
      filewrite(wealth_code, "end if.");
      filewrite(wealth_code, "variable labels !2 !3.");
      filewrite(wealth_code, "value labels !2 0 'No' 1 'Yes'.");
      filewrite(wealth_code, "formats !2 (f1.0).");
      filewrite(wealth_code, "!enddefine.");
      filewrite(wealth_code, "");

      { Macro - no2zero - for converting Yes/No (1/2) to (1/0) }
      filewrite(wealth_code, "*{Reset missing values to 'does not have', change 2 code to 0}.");
      filewrite(wealth_code, "define no2zero( !positional !tokens(1) )");
      filewrite(wealth_code, "if (missing(!1) | !1<>1) !1=0.");
      filewrite(wealth_code, "value labels !1 0 'No' 1 'Yes'.");
      filewrite(wealth_code, "!enddefine.");
      filewrite(wealth_code, "");

      { Variable recoding starts here }
      filewrite(wealth_code, "*{Construct Variables}.");
      process_spss();

      { Add number of persons per sleeping room }
      filewrite(wealth_code, "*{Members per sleeping room}.");
      filewrite(wealth_code, "if (hhusual=0) hhusual=hhslept.");
      filewrite(wealth_code, "if (AH127>0) memsleep=trunc(hhusual/AH127).");
      filewrite(wealth_code, "if (AH127=0) memsleep=hhusual.");
      filewrite(wealth_code, "if (missing(AH127) or AH127>=99 or memsleep>=98) memsleep=99.");
      filewrite(wealth_code, "variable labels memsleep 'Number of members per sleeping room'.");
      filewrite(wealth_code, "value labels memsleep 0 'Less than 1 per room'.");
      filewrite(wealth_code, "formats memsleep (f2.0).");
      filewrite(wealth_code, "missing values memsleep (99).");
      addtovarstr("memsleep",1);

      { Create urban and rural variables }
      filewrite(wealth_code, "");
      filewrite(wealth_code, "* Compute urban and rural variables coded (1/0) for filters later.");
      filewrite(wealth_code, "compute urban=(AHTYPE = 1).");
      filewrite(wealth_code, "compute rural=(AHTYPE = 2).");
      filewrite(wealth_code, "variable labels urban 'Urban' / rural 'Rural'.");
      filewrite(wealth_code, "value labels urban 1 'Urban' / rural 1 'Rural'.");
      filewrite(wealth_code, "formats urban rural (f1.0).");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "execute.");

      { Frequencies of input variables and recoded variables }
      filewrite(wealth_code, "");
      filewrite(wealth_code, "* Check on indicator variable creation.");
      filewrite(wealth_code, "frequencies variables=AHTYPE to land.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "* Toilet facility by shared/not shared.");
      filewrite(wealth_code, "crosstabs /tables=AH109 by AH110.");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "* Land area by units - if there are separate units - need to convert them to one unit.");
      filewrite(wealth_code, "*crosstabs /tables=AH131N by AH131U.");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "frequencies variables=");
      output_varlist(2);
      filewrite(wealth_code, ".");
      filewrite(wealth_code, "");

      { Ensure weights are off, and save the recoded assets file }
      filewrite(wealth_code, "* Turn off weights before all factor analysis.");
      filewrite(wealth_code, "weight off.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "* Name the dataset window for the HH data for use later.");
      filewrite(wealth_code, "dataset name assets.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "save outfile='assets.sav'.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "");

      { Factor analyses start here - first test }
      factor_code("Test", "", "");

      { Note on common variables to exclude }
      filewrite(wealth_code, "*** Common Factor analysis ***.");
      filewrite(wealth_code, "** Removed area-specific variables **.");
      filewrite(wealth_code, "** Agricultural animal variables excluded");
      filewrite(wealth_code, "** Land area excluded");
   // filewrite(wealth_code, "** Any others ?.");
      filewrite(wealth_code, "");

      { Factor analyses for Common, Urban and Rural }
      factor_code("Common", "", "com");
      factor_code("Urban", "urban", "urb");
      factor_code("Rural", "rural", "rur");

      { Rename the scores variables }
      filewrite(wealth_code, "* Label the created score variables.");
      filewrite(wealth_code, "rename variables (com1 urb1 rur1=comscore urbscore rurscore).");
      filewrite(wealth_code, "variable labels comscore 'Common wealth score' /urbscore 'Urban wealth score' /rurscore 'Rural wealth score'.");
      filewrite(wealth_code, "");

      { Add a variable for linking for the regressions }
      filewrite(wealth_code, "* Add a variable used for linking later.");
      filewrite(wealth_code, "filter off.");
      filewrite(wealth_code, "string rowtype_ (A8).");
      filewrite(wealth_code, "compute rowtype_ = 'EST'.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "");

      { Run the regressions and merge the results }
      regress_code("urban","urb");
      regress_code("rural","rur");

      { clean up the temporary datasets }
      filewrite(wealth_code, "dataset close %scorv.","urban");
      filewrite(wealth_code, "dataset close %scorv.","rural");
      filewrite(wealth_code, "dataset activate assets.");
      filewrite(wealth_code, "filter off.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "");

      { Calculate the combined wealth score from the urban and rural scores }
      filewrite(wealth_code, "*** Calculate combined wealth score from Urban and Rural Scores.");
      filewrite(wealth_code, "* Use coefficients from urban and rural regressions above.");
      filewrite(wealth_code, "compute combscor=0.");
      filewrite(wealth_code, "print formats combscor (f11.5).");
      filewrite(wealth_code, "write formats combscor (f11.5).");
      filewrite(wealth_code, "** Urban.");
      filewrite(wealth_code, "if (urban = 1) combscor=urbconst+urbcoeff*urbscore.");
      filewrite(wealth_code, "** Rural.");
      filewrite(wealth_code, "if (rural = 1) combscor=rurconst+rurcoeff*rurscore.");
      filewrite(wealth_code, "variable labels combscor 'Combined national wealth score'.");
      filewrite(wealth_code, "execute.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "");

      { Weight the data according to the household weight }
      filewrite(wealth_code, "compute hhwt = AHWEIGHT/1000000.");
      filewrite(wealth_code, "variable labels hhwt 'HH weights'.");
      filewrite(wealth_code, "formats hhwt (f12.6).");
      filewrite(wealth_code, "weight by hhwt.");
      filewrite(wealth_code, "");

      { Histograms for combined score }
      freq_code("", "com");
      freq_code("urban", "urb");
      freq_code("rural", "rur");
      filewrite(wealth_code, "filter off.");
      filewrite(wealth_code, "execute.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "");

      { Calculate quintiles }
      filewrite(wealth_code, "*Calculate quintiles and scores for data file.");
      filewrite(wealth_code, "compute hhmemwt=AHWEIGHT*hhusual/1000000.");
      filewrite(wealth_code, "variable labels hhmemwt 'HH members weighting for index'.");
      filewrite(wealth_code, "formats hhmemwt (f12.6).");
      filewrite(wealth_code, "weight by hhmemwt.");
      filewrite(wealth_code, "");

      rank_code("urban","urbscore");
      rank_code("rural","rurscore");
      rank_code("","combscor");

      filewrite(wealth_code, "variable labels ncombsco 'Combined wealth index' /nurbscor 'Urban wealth index' /nrurscor 'Rural wealth index'.");
      filewrite(wealth_code, "value labels ncombsco nurbscor nrurscor 1 'Lowest' 2 'Second' 3 'Middle' 4 'Fourth' 5 'Highest'.");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "*** Check on quintiles.");
      filewrite(wealth_code, "frequencies variables=ncombsco nurbscor nrurscor.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "weight by hhwt.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "ctables /table (");
      output_ctablist();
      filewrite(wealth_code, "  )[S][Mean F8.3] by (ncombsco+nurbscor+nrurscor)[C]");
      filewrite(wealth_code, "  /slabels visible=no.");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "* Alternative instead of ctables.");
      filewrite(wealth_code, "*means tables=");
      output_varlist(2);
      filewrite(wealth_code, "    by ncombsco nurbscor nrurscor");
      filewrite(wealth_code, "  /cells mean count stddev.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "graph /histogram(normal)=combscor /title= 'Distribution of Households by Wealth Scores'.");
      filewrite(wealth_code, "frequencies variables=combscor");
      filewrite(wealth_code, "  /format=notable");
      filewrite(wealth_code, "  /ntiles=5");
      filewrite(wealth_code, "  /statistics=stddev minimum maximum semean mean median mode skewness seskew kurtosis sekurt");
      filewrite(wealth_code, "  /order=analysis.");
      filewrite(wealth_code, "");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "weight off.");
      filewrite(wealth_code, "filter off.");
      filewrite(wealth_code, "write formats combscor urbscore rurscore (f11.5).");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "* Save final dataset of assets.");
      filewrite(wealth_code, "save outfile='assets.sav'.");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "*** Write out scores file.");
      filewrite(wealth_code, "write outfile='scores.dat' table /AHCLUST AHNUMBER combscor ncombsco urbscore nurbscor rurscore nrurscor.");
      filewrite(wealth_code, "execute.");
      filewrite(wealth_code, "");

      filewrite(wealth_code, "* Produce table 2.6 weighted by de jure population to test.");
      filewrite(wealth_code, "weight by hhmemwt.");
      filewrite(wealth_code, "compute total = 0.");
      filewrite(wealth_code, "variable labels total 'Total'.");
      filewrite(wealth_code, "value labels total 0 ' '.");
      filewrite(wealth_code, "ctables /vlabels variables=AHTYPE AHREGION total Ncombsco display=both");
      filewrite(wealth_code, "  /table AHTYPE [C] + AHREGION [C] + total [C] BY Ncombsco [C][rowpct.count '%' F8.1, totals [rowpct.count '%' F8.1, count '' F8.0]]");
      filewrite(wealth_code, "  /categories variables=Ncombsco total=yes");
      filewrite(wealth_code, "  /titles title='Table 2.6 Wealth Quintiles' ''");
      filewrite(wealth_code, "    'Percent distribution of the de jure population by wealth quintiles, according to residence and region, %s %s %s'", Country, SType, Year);
      filewrite(wealth_code, "  corner='Residence/region' /slabels visible=no.");
      filewrite(wealth_code, "");

    { do i = 1 while i <= nVars
        write("%s: %s",Varnames(i), Varlabels(i));
      enddo;
     }
      { Close the SPSS file }
      close(spss_code);
      close(spss_inc);
      close(wealth_code);
	  filecopy("wealth_index_start.sps","wealth_index.sps");
      filedelete(fname + ".temp");
      filerename(fname, fname + ".temp");
      filerename(fname + ".tmp", fname);

    else
      errmsg("Failed to open .SPS file: %s", fname);
    endif;

  end;

  {------------------------------------------------------------------ }
PROC CCIQ81_FF
preproc

  { Set to export SPSS }
  set behavior() export (SPSS, SubItemOnly);
  { Get the filename of the output asset file }
  fname = filename(wealth_assets);
  errmsg("Filename: %s", fname);

  
postproc
  { Code to create SPSS commands for Wealth index construction }
  create_spss();

PROC HOUSEHOLD
preproc

  if AHRESULT <> 1 then skip case; endif;

  hhmembers = totocc(AHSEC01_EDT);
  hhusual = count(AHSEC01_EDT where AH05 = 1);
  hhslept = count(AHSEC01_EDT where AH06 = 1);

  domestic = 0;
  land = 0;
  if AH130 = 1 then land = 1; endif;
  house = 0;
  { if ownership of house asked in household questionnaire !!!}
  { if AHXXX = 1 then house = 1; endif; }
  MobPhone = 0;
  if AH133B = 1 then MobPhone = 1 endif;
  CheckAcc = 0;
  if AH134 = 1 then CheckAcc = 1 endif;

  
postproc
  { Code for exporting the asset variables - used from postproc of household as some variables are created from the individual questionnaires }
  export to wealth_assets case_id (AHCLUST, AHNUMBER)
            AHWEIGHT, AHREGION, AHTYPE, hhmembers, hhusual, hhslept,
            AHSEC02 exclude(AH108),
			MobPhone, CheckAcc,
            AHSEC04 exclude(AH151),
            {domestic,} house, land;  { Drop alpha variables !!!}

  frequency include(AHREGION, AHTYPE, hhmembers, hhusual, hhslept,
                    AHSEC02 numeric alpha,
                    AHSEC04 numeric alpha, {domestic,} house, land)
            exclude(AH108,AH151); { Drop alpha variables !!!}

PROC INDIVIDUAL
preproc
{ domestic no longer used - 5/17/2022
  { Woman is a domestic worker and is not related to head of household }
  if A913 = maid_code & AH03(ALINE) = not_related then domestic = 1; endif;
  { Woman's partner is a domestic worker, listed in the household and is not related to head of household }
  if A908 = maid_code & A710 in 1:AHMEMBER & AH03(A710) = not_related then domestic = 1; endif;

  { Man is a domestic worker and is not related to head of household }
  if AM604 = maid_code & AH03(ALINE) = not_related then domestic = 1; endif;
}
  { Add code for ownership of land or house if asked in individual women or men's questionnaires - !!! }
  { Only used to set land or house = 1.  Already initialized to 0 in the preproc for the household }
  if AH05(ALINE) = 1 & A925 in 1:5 then house = 1; endif;
  if AH05(ALINE) = 1 & A928 in 1:5 then land  = 1; endif;

  if AH05(ALINE) = 1 & AM612 in 1:5 then house = 1; endif;
  if AH05(ALINE) = 1 & AM615 in 1:5 then land  = 1; endif;
  
  { Modify ownership of mobile phone and possesion of checking account based on individual interview }
  if AH05(ALINE) = 1 & A122  = 1 then MobPhone = 1; endif;
  if AH05(ALINE) = 1 & A930A = 1 then CheckAcc = 1; endif;
  
  if AH05(ALINE) = 1 & AM122  = 1 then MobPhone = 1; endif;
  if AH05(ALINE) = 1 & AM617A = 1 then CheckAcc = 1; endif;
