{Application 'REFORMATSDG' logic file generated by CSPro}
PROC GLOBAL

file sdg;
list string lines, linesout;
string subhead = "{9999.9}";
{ !!! string subhead = "{9999,9}"; use this instruction when having comma as a separator }
numeric g {goal index}, 
		h {heading index}, 
		i {index into lines}, 
		j {index for lines out}, 
		len {length of remaining part of string }, 
		n {table number}, 
		p {position in string}, 
		q {2nd position in string}, 
		x {offset position}, 
		opengoal {whether last line of goal is still to be found}, 
		col {column in table}, 
		colmax {max columns for this line - depends on the line},
		cols = 5; { number of columns in table - includes stub, urban/male, rural/female, total and DHS Table number columns. 
		  Typically 5, but may be 6 or 7 if residence has 3 or 4 categories.  Also need to expand sex to 3 or 4 categories in that case }
numeric start = 1;
string numstr, newstr;
array goal(17,2); // goals by start and end
array heading(2,2); // headings start and end
numeric pagenum = 0;
numeric priorhead = 0; // heading used for prior goal - doesn't need to be output if the same

{ Replace text in line with new text between p1 and p2 positions (not including p1 and p2) }
{ Copies from position 1 to p1, adds midstr, then copies from p2 to the end }
function replaceline(ix, p1, string midstr, p2)
  lines(ix) = lines(ix)[1:p1] + midstr + lines(ix)[p2:length(lines(i))-p2+1];
end;

{ Find the CSPro generated table number, e.g. 1004.0 or 305.1 and sets numstr if it is found }
function gettable_num();
  len = length(lines(i));
  p = 1;
  // find 4th li0{..} where the table name is kept. No 'li0{' in stub column
  do col = 2 while col <= cols
    x = pos("li0{",lines(i)[p:len]);
	if x & pagenum then
	  inc(p,x+3);
	  inc(len,-x-3);
	  if lines(i)[p:1] = "}" then // not a data row
	    break
	  endif;
	  // write("i=%d x=%d p=%d len=%d str=%s",i,x,p,len,lines(i)[p:len]);
	else
	  break;
	endif;
  enddo;
  // have a cell with a table number in it
  if col >= cols then // found 4th cell. 4th one is table number.
    // inc(p,3);
	// inc(len,-3);
	q = pos("}",lines(i)[p:len]);
	numstr = lines(i)[p:q-1]; // gets the table number string
	exit 1;
  endif;
  exit 0; // no table number
end;

{ Corrects the table number, e.g. from 1004.0 to 10.4, or from 305.1 to 3.5.1 }
function settable_num();
  n = tonumber(numstr);
  newstr = maketext("%d.%d",int(n/100),n%100); // make new table number
  if numstr[q-1:1] <> "0" then
	newstr = newstr+"."+numstr[q-1:1]; // add third level to table number if needed
  endif;
  replaceline(i,p-1,newstr,p+q-1); // regenerate string with corrected table number
  // lines(i) = lines(i)[1:p-1] + newstr + lines(i)[p+q-1:len-q+1]; // regenerate string
  // errmsg("newstr=%s",newstr);
  // errmsg("i=%d %s",i,lines(i));
end;

{ Finds the start and end lines for the goal }
function goaldata();
  if pos("{\b _}", lines(i)) then // start of an SDG goal - this is just a bold underscore
    x = pos("{\b", lines(i+1)); // start of an SDG goal - next line really starts the goal with the goal name
	n = tonumber(lines(i+1)[x+4:2]); // gets the goal number
	if opengoal | start then // if we are at the start of a new goal, or just after the intro text with the date, then close the open goal
	  goal(opengoal,2) = i-1; // close the prior goal
	  start = 0; // no longer in the intro text
	endif;
	goal(n,1) = i; // start of new goal
	opengoal = n; // goal that is open
	lines(i) = replace(lines(i), "{\b _}", "{\b  }"); // remove the underscaore from the output
  endif;
end;

{ Change the number of decimals to 1 for the fertility and mortality indicators}
function fertmort();
  { loop through goal 3 data that contain the fertility and mortality data }
  do i = goal(3,1) while i <= goal(3,2)
    { find the indicators that require no decimals }
	if pos("3.1.1 ",lines(i)) | 
	   pos("3.2.1 ",lines(i)) | 
	   pos("3.2.2 ",lines(i)) | 
	   pos("3.7.2 ",lines(i-1)) | // 3.7.2a)
	   pos("3.7.2 ",lines(i-2))   // 3.7.2b)
	then
	  p = 1;
	  len = length(lines(i));
	  { Loop through 2nd to 4th columns for the data with '\li0' }
	  do col = 2 while col < cols
	    x = pos("li0{",lines(i)[p:len]);
        if x then
	      inc(p,x+3); // increment position to the {
	      inc(len,-x-3);
	      q = pos("}", lines(i)[p:len]); // offset for the end of the text to remove
		  if q & pos(".0", lines(i)[p+q-2:2]) then
		    replaceline(i,p+q-4,"",p+q-1); // remove the '.0' text after the fertility and mortality data
		    // lines(i) = lines(i)[1:p+q-4] + lines(i)[p+q-1:len-q+1]; // remove the '.0' text after the fertility and mortality data
	      endif;
	    endif;
	  enddo;
	endif;
  enddo;
end;

{ Add super a to the total column for those indicators that are arithmetic means of the male and female data }
function add_a()
  do i = 1 while i <= lines.length() // loop through all lines
    // restrict to goals 3,5,8,17 that contain the inidcators that need the superscript a, and then limit to those indicators
    if i in goal(3,1):goal(3,2), goal(5,1):goal(5,2), goal(8,1):goal(8,2), goal(17,1):goal(17,2) & 
	  (pos("3.a.1 ",lines(i)) |
	   pos("5.b.1 ",lines(i)) |
	   pos("8.10.2 ",lines(i)) |
	   pos("17.8.1 ",lines(i)))
	then
	  p = 1;
	  len = length(lines(i));
	  { Loop through 2nd to 4th columns for the data with '\li0' which precedes the number }
	  do col = 2 while col < cols
	    x = pos("li0{",lines(i)[p:len]);
        if x then
	      inc(p,x+2); // increment position to the '{' that precedes the number
	      inc(len,-x-2); // decrement the length
	      q = pos("}", lines(i)[p:len]); // offset for the end of the number text
		  if q & col = cols-1 then // if found the closing '}' and we are in the 4th column (for the total)
            // add superscript 'a' after the number in the cell and before the closing '}'
			replaceline(i,p+q-2,"{\super a}",p+q-1);
		    // lines(i) = lines(i)[1:p+q-2] + "{\super a}" + lines(i)[p+q-1:len-q+1]; 
	      endif;
	    endif;
	  enddo;
	endif;
  enddo;
end;

{ Finds the start and end heading lines for the tables }
function findheadings();
  // heading(0) is from the first table with the date, heading(1) is by sex, heading(2) is by residence
  if pos("{}\cell",lines(i)[1:7]) then
    heading(pagenum,1) = i-1; // start of heading
  elseif pos("\ql{",lines(i)[1:4]) then
    heading(pagenum,2) = i; // end of heading
  endif;
end;

{ Removes extra borders in the headings that are not wanted }
function redoheadingborders(main);
  // main = 0 for adding a border beneath the word "residence" or "sex"
  // main = 1 for removing borders for the stub (1st column) and DHS table number (column 4 or 5 depending on which row we are in)
  string top = "\clbrdrt", bottom = "\clbrdrb", brdrs = "\brdrs", border = "\brdrw10", bordernone = "\brdrnone"; // rtf codes for top, bottom, borders, border width 10, and no border
  numeric topbord; // if line is for the top border
  { Loop through both sets of headings - sex and residence }
  do h = 1 while h <= 2
    { Loop through each line of the heading }
    do i = heading(h,1) while i <= heading(h,2)
      topbord = 0;
      len = length(lines(i)); // remaining length of line
	  p = 1; // current position in line
	  colmax = cols;
	  
	  { Remove lines for first and last column from top and bottom borders of headings }
	  { Loop through each column of data - 4 columns for the top header, 5 columns for the bottom header }
	  do col = 1 while col <= colmax
	  
	    { Find the top or bottom border commands }
	    x = pos(top+brdrs+border,lines(i)[p:len]);
		if x then topbord = 1; colmax = 4 endif; // found top border - this row only has 4 columns (stub, 'sex'/'residence', total, table number
		if x = 0 then
	      x = pos(bottom+brdrs+border,lines(i)[p:len]); // found bottom border
        endif;

		{ Remove top or bottom border in the first (label) and last (table number) columns }
        if x & main then
	      inc(p,x-1); // update position in line
		  inc(len,-x+1); // decrement length
		  q = p+length(top)+length(brdrs)+length(border); // offset for data in line after the data to be changed
		  // errmsg("h=%d col=%d colmax=%d len=%d s=%s",h,col,colmax,length(lines(i)[p:len]),lines(i)[p:len]);
		  // errmsg("col=%d x=%d p=%d len=%d q=%d",col,x,p,len,q);
	      if col in 1,colmax then 
		    // remove top or bottom border for columns 1 (label) and 5 (table number)
			replaceline(i,p+length(top)-1,bordernone,q);
		    // lines(i) = lines(i)[1:p+length(top)-1] + bordernone + lines(i)[q:len-(q-p)+1];
		  endif;
		  inc(p); // reposition to just after the prior position 
		  len = length(lines(i))-p+1; // readjust the remaining length
		else 
		  break;
		endif;
		
      enddo;

      { Top header - need to add the border directly under 'Sex' or 'Residence' }
      if topbord then 
        len = length(lines(i)); // remaining length of line
	    p = 1; // current position in line
	    { Loop through first 2 columns of data. Only need to change the second one }
	    do col = 1 while col <= 2
		  { Find the bottom border command with none }
	      x = pos(bottom+bordernone,lines(i)[p:len]);
		
		  { Replace top or bottom border in the first (label) and last (table number) columns }
          if x then
	        inc(p,x-1);
		    inc(len,-x+1);
		    q = p+length(top)+length(bordernone); // offset for data in line after the data to be changed
		    if col = 2 then // add bottom border for column 2 (Sex or Residence)
			  replaceline(i,p+length(top)-1,brdrs + border,q);
		      // lines(i) = lines(i)[1:p+length(top)-1] + brdrs + border + lines(i)[q:len-(q-p)+1];
			  break;
		    endif;
		    inc(p); // reposition to just after the prior position 
		    len = length(lines(i))-p+1; // readjust the remaining length
		  else
		    break;
		  endif;

		enddo;
      endif;

	  { Find the lines with Indicator and DHS Table number }
      if main & pos("\ql{", lines(i)[1:4]) then // Text for 'Indicator' and 'DHS Table number' is preceded by '\ql{\'
	    x = pos("}",lines(i)); // find closing brace
		if x then 
		  replaceline(i,4,"",x);
		  // lines(i) = lines(i)[1:4] + lines(i)[x:length(lines(i))-x+1]; // Removes Indicator
		endif;
		
		p = 1;
		len = length(lines(i));
		{ Loop through 2nd to 5th columns for the column headings with 'qc' (first uses 'ql') }
		do col = 2 while col <= cols
		  x = pos("\qc{",lines(i)[p:len]); // search for '\qc{' which precedes the text for each column
          if x then
	        inc(p,x); // increment position 
		    inc(len,-x); // decrement remaining length
		  endif;
		  if col = cols then // column for the table number
		    inc(p,3); // positioned at the beginning of the text to remove
		    q = pos("}", lines(i)[p:len]); // offset for the end of the text to remove
			if q then
			  replaceline(i,p-1,"",p+q-1); // remove the 'DHS Table number' text
			  // lines(i) = lines(i)[1:p-1] + lines(i)[p+q-1:len-q+1]; // remove the 'DHS Table number' text
			endif;
		  endif;
		enddo;

	  endif;
	  
	enddo;
  enddo;
end;

{ Output headings - by sex (heading 1) or residence (heading 2) }
function output_heading();
  x = (g in 1,6,7) + 1; // Goals 1, 6, and 7 from second table (2), the rest from the first table (1)
  if g & x <> priorhead then // different heading needed
    do h = heading(x,1) while h <= heading(x,2) // loop through lines for the heading needed
      linesout(j) = lines(h); // output the lines needed
	  inc(j);
	  inc(i);
	enddo;
	linesout(j) = ""; // add a blank line (probably not needed, just for clarity)
	inc(j);
  endif;
  priorhead = x; // remembers the land heading output
end;

{ Output goal data }
function output_goal();
  // errmsg("goal %2d: %4d %4d", g, goal(g,1), goal(g,2));
  do i = goal(g,1) while i <= goal(g,2)
    // goal=0 is all of the initial lines of the rtf before the data starts
	if g = 0 & i = heading(1,1) then 
	  break; // done the intro lines and now found the first heading which we don't need to output, so break out for the 1st actual goal
	else
	  if g = 0 | i > goal(g,1) then // ignore first empty line for the goal
        linesout(j) = lines(i); // output the lines for the goal
	    inc(j);
	  endif;
    endif;
  enddo;
end;
{
// display the heading lines - only used for testing
function displayheadinglines();
  do h = 1 while h <= 2
    do i = heading(h,1) while i <= heading(h,2)
	  errmsg("h=%d i=%d %s",h,i,lines(i));
	enddo;
  enddo;
end;
}

PROC SDGDEFINED_FF
preproc
// Read in the SDG definitions
// not needed - may use this in a later version of this application

postproc
// Read the SDG tables into a list
sdg.open ("ChaptSDG.rtf");
sdg.read (lines);
sdg.close();

goal(0,1) = 1; // start of the intro text (treated as goal 0)
start = 1;
{ Loop through lines in the RTF file to identify tables, headings, goals, etc., and make fixes for certain characters }
do i = 1 while i <= lines.length()

  { Page number - 1 = main table, 2 = second part, 0 = date ran }
  if pos("\page",lines(i)) then 
    inc(pagenum);
  endif;

  { Close prior goal if one is open when reaching a new page or the end of the file }
  if opengoal & (pos("\page",lines(i)) | lines(i)[1:1] = "}") then
    goal(opengoal,2) = i-1; // close the prior goal
	opengoal = 0;
  endif;
  
  { Subheadings - drop table 9999.9 table number and the - in the data cells }
  if pos(subhead,lines(i)) then
    lines(i) = replace(lines(i),subhead,"{}");
    lines(i) = replace(lines(i),"{-}","{}");
  endif;

  { Find the table headings for table 0 (intro), 1 (by sex), 2 (by residence) }
  findheadings();
  
  { Table numbers - get the number in numstr}
  if gettable_num() & numstr <> "-" then 
    settable_num(); // replace the number with the format needed.
  endif;
  
  { Find the start of each section (goal) }
  goaldata();

  { Remove solid border from last goal in second table }
  if i > lines.length()-6 then
    lines(i) = replace(lines(i), "\brdrs\brdrw45", "\brdrnone");
  endif;

  { Fix issues related to the write command }
  lines(i) = replace(lines(i),"\f","\\f"); // as write output \f as form feed and \n as newline, need to add extra \
  lines(i) = replace(lines(i),"\n","\\n"); 
  { Handle hard spaces in the file (non-breaking spaces) }
  lines(i) = replace(lines(i)," "{nbsp}," "); // the character in the first quoted string is a non-breaking space character that looks blank.  Do not replace with a blank.
  lines(i) = replace(lines(i),"Â"," "); // a non-breaking space character converted. Replace this too.
enddo;

{ Convert fertility and mortality rates to no decimals }
fertmort();

{ Add superscipt a to certain indicators }
add_a();

{ Loop through goals and combine table 2 entries (by residence) into table 1 (by sex) }
redoheadingborders(0); // only adds border under Residence
j = 1;
do g = 0 while g <= 17
  if goal(g,1) then
    output_heading();
	if g = 1 then
	  redoheadingborders(1); // redos other borders
	  // displayheadinglines();
    endif;
    output_goal();
  endif;
enddo;
// output last line of rtf file, closing the rtf structure
linesout(j) = "}";

// write corrected SDG output
sdg.open ("ChaptSDG_"+edit("99-99-9999",sysdate("MMDDYYYY"))+"_reformat.rtf", create);
sdg.write(linesout);
sdg.close();
