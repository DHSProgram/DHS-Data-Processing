PROC GLOBAL
{ DHS-8 secondary editing application  Version 1.0.0 of 08/10/2020 }

  { To store couples information to compare at postproc level 1            }
  { Columns are: 1-Resp. line  2-Resp. marital status  3-husband/wife line }
  array womhusb(20,3);
  array manwife(20,3);

  { Counts of error messages that are not displayed }
  array kount(50);
  
  { Arrays to check duplicate HH line numbers in birth histories }
  array persline(50);
  array mothline(50);

  { --- Event table variables ---------------------------------------------------------------}
  { in DHS-8 duration of amenorrhea and abstinence were removed. Duration of breastfeeding   }
  { was removed several phases before.  If those variables are included for the survey bring }
  { logic from DHS-7 for arrays "duramen", "durabst", and "durbf and the corresponding flags } 
  array type     (30);        { event type }
  array norder   (30);        { event order }
  array twincode (30);        { if a child is twin or not }
  array surv     (30);        { child's survival status }
  array sflag    (30);        { date flag }
  array smonth   (30);        { if month for event was given }
  array errflag  (30);        { event error flag }
  array lcmc     (30);        { event lower CMC }
  array ucmc     (30);        { event upper CMC }
  array cmc      (30);        { event imputed CMC }
  array interv   (30);        { interval to following event }
  array cdelay   (30);        { delay for pregnancy between events }
  array durmeth  (30);        { duration of contraception use }
  array calrow   (30);        { birth row in the calendar }
  array flagmeth (30);        { flag duration of contraception use }
  array flagdth  (30);        { flag for age at death }
  array deathl   (30);        { age at death lower limit }
  array deathu   (30);        { age at death upper limit }
  array lstdu    (30);        { age at death units for hot deck imputation }
  array lstdn    (30);        { age at death number of units for hot deck imputation }
  array pregdur  (30);        { used to check pregnancy duration in months in calendar }

 { --- working variables ------------------------------------------------------------------------ }

  numeric lper, lperflag, lsex, lsexflag, fsex, fsexflag, sexp, marrs;
  numeric temp, calbeg, calend, calbegY, calendY, xrow, ycmc, callen, calint, caluse, currUser;
  numeric ouse, fuse, luse, pregs5, chadj, colw, calcmc, usem, muse, preg, xuse, used;
  numeric ismonth, isyear, isage, isday, flag, nEvents, LcmcB, LcmcM, UcmcB, UcmcM;
  numeric b, e, i, j, k, m, mRow, n, t, v, x, y;
  numeric ch, cy, cm, cd, dy, dm, dd, rp, rc, x1, x2, du, dn, di, xy, xm, xd, vd, vy, vm, rw, rh, eno;
  numeric mind, minai, mindb, minaim, minabm, minam, min2m, minamm, minau, minaum;
  numeric minas, minab, mincd, minpd, lmax, lmin, maxd, maxai, maxdb, maxaim, maxabm;
  numeric maxelig, maxevent, maxmemb, LastSrc, MinAsx;
  numeric LastVacD, LastVacM, LastVacY;
  numeric stermeth, stermetm, methoth, currpreg, calpreg, xmeth;
  numeric xho, xhc, xhi; { # HHs, # HHs completed, # HHs incomplete }
  numeric xww, xwc, xwi, xmm, xmc, xmi, xht, xwt, cmcTerm, tryMatch;
  numeric xusing;
  numeric run1, doimp, dprev, ver100, ignoreY, emsample;
  numeric yage, hwage, err, rok, fline_valid, mLine_valid, hwlcmc, hwucmc, hwsex, Totpreg, hwerr;
  numeric ageDU, ageDN, ageD, dam, dab, head, ntwin, uMin, agew, agem;
  numeric inUnion, EverUnion, nwives, dviol;
  numeric gap, gap2, xgap, xDateMin, xDateMax, dMonths, jInterv;
  numeric goodLink, found, xdeath, discont, condom;
  numeric swrt, anew, aold, iold, aoldest, ETsuppress;
  numeric prevCL, xmonth, xyear, xday; { previous cluster # }
  numeric valf, valm, sickmem,deadmem, deadpar, chvulner, termin, PrvHHnum;
  numeric preg35, birth59, birth23, currpregdur;
  numeric cusmonth, cusflag, cuerrflag;
  numeric WeeksMonth = 0.23;
  
  alpha(1)  onemeth;              { method as a character to use with calendar }
  alpha(1)  asterisk, spaces;     { asterisks and spaces for printing purposes }

  string  calmeth;              { codes for contraceptive methods in calendar }
  string  pregstr;              { three characters for pregnancy status }
  string  codeb, codep, codet;  { one character for births, pregnancies and terminations }
  string  vstring, xstring;     { text vaccination names }
  string  curmethw;             { current method in woman questionnaire }
  string  curmethm;             { current method in man questionnaire }
  string  calw;                 { working calendar column }
  string  sdeath;               { to display age at death as a string }

  { --------------------------------------------------------------------------- }
  { Function to convert CMC to a calendar row }
  function cmcrow( xcmc );
    if !xcmc in calbeg:calend then
      xrow = 0
    else
      xrow = calend-xcmc+1
    endif;
    cmcrow = xrow;
  end;

  { Function to convert a calendar row to CMC }
  function rowcmc( yrow );
    if !yrow in  1:callen then
      ycmc = 0
    else
      ycmc = calend-yrow+1
    endif;
    rowcmc = ycmc;
  end;

  { Function to get a month from a CMC }
  function cmc2m( xcmc );
    cmc2m = (xcmc-1)%12+1;
  end;

  { Function to get a 4 digits year from a CMC }
  function cmc2y( xcmc );
    cmc2y = int( (xcmc-1)/12 ) + 1900;
  end;

  { convert the 3 components of a vaccination date into a variable to EDIT it later }
  function vdate( vday, vmonth, vyear )
    vdate = (vday*100+vmonth)*10000+vyear;
  end;

  { ------------------------------------------------------------------------ }
  { check if vaccinations are given on the same date under below conditions. }
  { These conditions suggest that there is a likely error in recording or    }
  { entering the vaccination dates                                           }
  function ckvdate( pd, pm, py, dptd, dptm, dpty )
  { Note: the following table is being used to decide whether a message is needed }
  { Day   Month   Year   Code  Result
    diff  diff    diff    0    No message
    same  diff    diff    1    No message
    diff  same    diff    2    Give message
    same  same    diff    3    Give message
    diff  diff    same    4    No message
    same  diff    same    5    Give message
    diff  same    same    6    Give message
    same  same    same    7    No message
  }
    n = (pd = dptd) + 2*(pm = dptm) + 4*(py = dpty);
    ckvdate = ( n in 2,3,5,6 );
  end

  { function to convert sex related variables to number of days }
  function sexdays( rvar )
    { Recode into days ago }
    recode rvar  -> x;
         100:196 -> (rvar-100);
         201:296 -> (rvar-200)*7;
         301:396 -> int((rvar-300)*365/12);
         401:496 -> int((rvar-400)*365.25);
                 -> 9998;    
	endrecode;
    sexdays = x;
  end;

PROC ccIN80_FF
preproc
  { get language from calling menu }
  SetLanguage( GetLanguage() );

  { Initializing the application before the first questionnaire }
  seed(101);            { Seed to start the random number generator }

  { set application parameters }
  minai    = 15;        { !!! Minimum age at interview - women         }
  maxai    = 49;        { !!! Maximum age at interview - women         }
  minab    = 144;       { !!! Minimum age at first birth - women       }
  minam    = 120;       { !!! Minimum age at marriage - women          }
  min2m    = 12;        { !!! Minimum interval between first and current marriage }
  minas    = 240;       { !!! Minimum age at sterilization             }
  {+MEN}
  minaim   = 15;        { !!! Minimum age at interview - men           }
  maxaim   = 59;        { !!! Maximum age at interview - men           }
  minabm   = 180;       { !!! Minimum age in months at birth     - men }
  minamm   = 180;       { !!! Minimum age in months at marriage  - men }
  maxelig  = 20;        { !!! Maximum number of eligible men or women  }
  {MEN+}
  mincd    = 2;         { !!! Minimum conception delay after birth     }
  maxevent = 30;        { !!! Maximum number of events                 }
  maxmemb  = 50;        { !!! Maximum number of household members      }
  run1     = 1;         { 1 if running secondary editing for the first time - 0 if no imputation   }
  doimp    = 0;         { 1 if doing imputation - 0 if no imputation   }
  dprev    = 0;         { 1 if doing DP review at end of fieldwork     }
  ver100   = 1;         { 1 if 100% verification                       }
  ignorey  = 0;         { 1 if ignoring year when age + year = interview year
                          0 if using year when age + year = interview year  }
  stermeth = 1;         { !!! occurrence for female sterilization in contraceptive table    }
  stermetm = 2;         { !!! occurrence for male sterilization in contraceptive table      }
  condom   = 7;         { !!! occurrence for male condom in contraceptive table             }
  methoth  = 14;        { !!! occurrence for other methods in contraceptive table           }
  emsample = 0;         { !!! Ever married sample - 0=No, 1=Yes       }
  preg35   = 35; 
  birth59  = 59;
  birth23  = 23;

  calendy  = 2020;      { !!! Year of end of calendar                    }
  calbegy  = 2015;      { !!! Year of start of calendar & health section }
  calend   = cmcode(12,calendy);              { last date of calendar    }
  calbeg   = cmcode( 1,calbegy);              { first date of calendar   }
  callen   = calend-calbeg+1;                 { length of calendar       }
                        { Row where births since 201? begin in calendar  }
  calmeth  = "123456789JKLMXY";     { !!! Codes for contraceptive methods in calendar }
  curmethw = "ABCDEFGHIJKLMXY";     { !!! Codes for contraceptive methods in A307     }
  curmethm = "ABCDEFGHIJKLMXY";     { !!! Codes for contraceptive methods in AM418.  male condom replaced by ~ on purpose }
  pregstr  = "BPT";                 { !!! Codes for Birth, Pregnancy and Termination  }
  codeb    = pregstr[1:1];
  codep    = pregstr[2:1];
  codet    = pregstr[3:1];

  prevCL   = notappl;           { previous cluster number }

  { initialize hot deck to impute age at death }
  do i = 1 while i <= maxevent
    lstdu(i) = 2;               { Units set initially as months }
    lstdn(i) = int((i-1)/10);   { Numbers within units as 0, 1, 2, 3 and 4 }
  enddo;

{ --------------------------------------------------------------------------- }
postproc 	{ of PROC ccIN80_FF }

  if dprev then
    errmsg( 90000, 0460, kount(28) );
    errmsg( 90000, 2360, kount(1) );
    errmsg( 90000, 2362, kount(12) );
    errmsg( 90000, 2364, kount(13) );
    errmsg( 90000, 2365, kount(14) );
    errmsg( 90000, 2366, kount(15) );
    errmsg( 90000, 2367, kount(16) );
    errmsg( 90000, 2368, kount(17) );
    errmsg( 90000, 2369, kount(18) );
    errmsg( 90000, 4050, kount(2) );
    errmsg( 90000, 5152, kount(5) );
    errmsg( 90000, 5153, kount(6) );
    errmsg( 90000, 5154, kount(7) );
    errmsg( 90000, 5155, kount(8) );
    errmsg( 90000, 5156, kount(9) );
    errmsg( 90000, 5157, kount(10) );
    errmsg( 90000, 5158, kount(11) );
    errmsg( 90000, 5191, kount(24) );
    errmsg( 90000, 5192, kount(25) );
    errmsg( 90000, 5193, kount(26) );
    errmsg( 90000, 5194, kount(27) );
    errmsg( 90000, 9814, kount(19) );
    errmsg( 90000, 9815, kount(20) );
    errmsg( 90000, 9815, kount(21) );
    errmsg( 90000, 9914, kount(31) );
    errmsg( 90000, 9914, kount(32) );
    errmsg( 90000, 9915, kount(33) );
    errmsg( 90000, 9915, kount(34) );
    errmsg( 90000, 9916, kount(35) );
    errmsg( 90000, 9916, kount(36) );
    errmsg( 90000, 9917, kount(37) );
    errmsg( 90000, 9917, kount(38) );
    {+MEN}
    errmsg( 90000, 25153, kount(48) );
    errmsg( 90000, 25158, kount(49) );
    errmsg( 90000, 25191, kount(44) );
    errmsg( 90000, 25192, kount(45) );
    errmsg( 90000, 25193, kount(46) );
    errmsg( 90000, 25194, kount(47) );
    {MEN+}
  endif;

PROC INDIVIDUAL
preproc

  if PrvHHnum <> ANUMBER then
    { initialize arrays to check duplicates between birth history and HH members and }
    { to store the individual interview result to use when assigning HIV weights     }
    do i = 1 while i <= maxmemb
      persline(i) = 0;
      mothline(i) = 0;
    enddo;
    PrvHHNum = ANUMBER;
    if !loadcase( ccHH80, ACLUSTER, ANUMBER ) then
      errmsg( 0004, ANUMBER );
      clear( ccHH80 );
    endif;
  endif;

  { Set up CMC for date of interview }
  di = cmcode( AINTM, AINTY );
  calint = calend - di + 1;

  if YCLUSTER <> ACLUSTER then 
    YCLUSTER = ACLUSTER; 
    clear(CLUSTERS); 
    if loadcase(CLUSTERS, YCLUSTER) then 
      if YREGION <> AREGION then  
        errmsg( 0015, AREGION,AREGION,YREGION,YREGIONN) 
      endif; 
      if YURBRUR <> ATYPE then  
        errmsg( 0017, ATYPE,ATYPE,YURBRUR,GetLabel(ATYPE,YURBRUR)); 
      endif; 
    else 
      errmsg( 0019, YCLUSTER ); 
      YCLUSTER = notappl; 
    endif; 
  endif; 

  if AQTYPE = 1 then
    mindb = di - (maxaim+1)*12 + 1;     { Minimum date of birth - men }
    maxdb = di - minaim*12;             { Maximum date of birth - men }
    xmm   = xmm + 1;
    if ARESULT = 1 then
{ *** enable at imputation time
      if AH06(ALINE) = 1 then
        AWEIGHT = MLWEIGHT;             { Men's weight }
      else
        AWEIGHT = 0;
      endif;
*** }
      xmc = xmc + 1
    else
      AWEIGHT = 0;
      xmi = xmi + 1
    endif;
  else
    mindb = di - (maxai+1)*12 + 1;      { Minimum date of birth - women }
    maxdb = di - minai*12;              { Maximum date of birth - women }
    xww   = xww + 1;
    if ARESULT = 1 then
{ *** enable at imputation time
      if AH06(ALINE) = 1 then
        AWEIGHT = WMWEIGHT;             { woman's weight }
        if ALINE = AHNUMDV & DV01 = 1 then
          dviol = count( AHSEC01_EDT where AH06 = 1 & AH09 <> 0 );
          if dviol > 5 then dviol = 5 endif;
          ADWEIGHT = DVWEIGHT(dviol);   { woman's domestic violence weight }
        else
          ADWEIGHT = 0;
        endif;
      else
        AWEIGHT  = 0;
        ADWEIGHT = 0;
      endif;
*** }
      xwc = xwc + 1
    else
{ *** enable at imputation time
      AWEIGHT  = 0;
      ADWEIGHT = 0;
*** }
      xwi = xwi + 1
    endif;
  endif;

  if doimp then
    AINTC = di;
    AINTCD = CDCode( AINTY, AINTM, AINTD );
  endif;
  Totpreg = 0;

  { Verify that interviewer is registered in fieldworker questionnaire }
  if !loadcase( FIELDWKQ, AINTNUM ) then
    errmsg( 0025, tr("Interviewer"), AINTNUM );
  endif;
  { Verify that supervisor is registered in fieldworker questionnaire }
  if !loadcase( FIELDWKQ, ASUPERV ) then
    errmsg( 0025, tr("Supervisor"), ASUPERV );
  endif;

{ ----------------------------------------------------------------------- }
{ respondent background questions }
PROC AWSEC01_EDT

  { Initialize event table }
  do i = 1 while i <= maxevent
    norder(i)  = default;     { Birth order of children }
    twincode(i)= default;     { Twin code for children }
    surv(i)    = default;     { Survival status for children }
    deathl(i)  = default;     { Age at death of child - lower limit }
    deathu(i)  = default;     { Age at death of child - upper limit }
    sflag(i)   = default;     { Status code flag }
    errflag(i) = default;     { Error flag }
    durmeth(i) = default;     { Duration of method use before birth }
    flagmeth(i)= 0;           { Flag for method use before birth }
    flagdth(i) = 0;           { Flag for age at death of the child }
    calrow(i)  = default;
  enddo;

  lperflag = 0;               { Flag for last period }
  lsexflag = 0;               { Flag for last sex }
  fsexflag = 0;               { Flag for age at first sex }
  cusflag  = 0;               { Flag for date of current union }
  inUnion = ( A701 in 1,2 );

{ --------------------------------------------------------------------------- }

  { Date of birth of the woman }

  { Check either year of birth or age given for all women }
  if !validyr(A110Y) & !valid(A111) then
    if run1 then errmsg( 1060, A110M, A110Y, A111 ); endif;
  { Compare age of woman with age in household to look for typos }
  elseif valid(A111) & !( (A111 - AH07(ALINE)) in (-2):2 ) then
    if run1 then errmsg( 1061, A111, AH07(ALINE) ) endif;
  endif;

  { Set up event table entry for woman's date of birth }
  nevents = 1;
  ismonth = valid(A110M);
  isyear  = validyr(A110Y);
  isage   = valid(A111);
  if ismonth then
    smonth(1) = A110M;
  else
    smonth(1) = 0;
  endif;
  recode isyear :: ismonth :: isage -> flag;
              1 ::       1 ::       -> 1;
                ::       1 ::     1 -> 2;
              1 ::         ::     1 -> 3;
              1 ::         ::       -> 5;
                ::         ::     1 -> 6;
                ::       1 ::       -> 7;
                ::         ::       -> 8;
  endrecode;
  if ignorey & flag = 3 & A110Y + A111 = AINTY then
    flag = 4
  endif;
  sflag(1)   = flag;
  errflag(1) = notappl;

  { Initial ranges for CMC date of birth }
  if validyr(A110Y) & (flag <> 4 | !doimp) then
    lcmcb = setlb( A110M, A110Y, 0 );
    ucmcb = setub( A110M, A110Y, 9999 );
    if lcmcb < mindb then
      if ucmcb < mindb then
        errmsg( 1063, A110M, A110Y, AINTM, AINTY, cmc2m(mindb), cmc2y(mindb), cmc2m(maxdb), cmc2y(maxdb) );
        errflag(1) = default;
        ucmcb = mindb;
      endif;
      lcmcb = mindb;
    endif;
    if ucmcb > maxdb then
      if lcmcb > maxdb then
        errmsg( 1063, A110M, A110Y, AINTM, AINTY, cmc2m(mindb), cmc2y(mindb), cmc2m(maxdb), cmc2y(maxdb) );
        errflag(1) = default;
        lcmcb = maxdb;
      endif;
      ucmcb = maxdb;
    endif
  else
    lcmcb = mindb;
    ucmcb = maxdb;
  endif;

  type(1) = 1;
  interv(1) = 0;
  cdelay(1) = 0;

{ --------------------------------------------------------------------------- }

  { Adjust ranges for CMC date of birth based on age }
  if A111 in minai:maxai then
    t = ndjlba( lcmcb, ucmcb, di, di, A111 );
    if t < 0 then
      errmsg( 1062, A110M, A110Y, lcmcb, ucmcb, A111, AINTM, AINTY, di );
      errflag(1) = default;
    else
      lcmcb = t;
    endif;
    t = adjuba( lcmcb, ucmcb, di, di, A111 );
    if t < 0 then
      errmsg( 1062, A110M, A110Y, lcmcb, ucmcb, A111, AINTM, AINTY, di );
      errflag(1) = default;
    else
      ucmcb = t;
    endif;
    x = di - (A111*12 + 11);
    if lcmcb < x & x <= ucmcb then
      lcmcb = x
    endif
  endif;

{ --------------------------------------------------------------------------- }

  { For month only without year, make adjustment }
  if ismonth & !isyear then
    x = int((lcmcb - 1)/12) * 12 + smonth(1);
    if x < lcmcb then
      x = x + 12
    endif;
    if x > ucmcb then
      if run1 then
        errmsg( 1064, smonth(1), lcmcb, ucmcb, cmc2m(lcmcb), cmc2y(lcmcb), cmc2m(ucmcb), cmc2y(ucmcb))
      endif;
    else
      lcmcb = x
    endif;
    x = int((ucmcb - 1)/12) * 12 + smonth(1);
    if x > ucmcb then
      x = x - 12
    endif;
    if x < lcmcb then
      if run1 then
        errmsg( 1064, smonth(1), lcmcb, ucmcb, cmc2m(lcmcb), cmc2y(lcmcb), cmc2m(ucmcb), cmc2y(ucmcb) )
      endif;
    else
      ucmcb = x
    endif;
  endif;

  { check duration of current residence }
  if A104 = 96 & AH05(ALINE) = 1 then
    errmsg( 1031, A104, AH05(ALINE) )
  endif;
  agew = int( (di-lcmcb) / 12 );
  if A104 in 0:49 & A104 > agew then
    errmsg( 1030, A104, A110M, A110Y, A111 )
  endif;
  if validyr(A106Y) & A104 in 0:49 then
    temp = setub(A106M, A106Y, 9999);
	if int((di-temp)/12) > A104 then
	  warning( 1035, A106M, A106Y, A104 )
	endif;
  endif;

{ --------------------------------------------------------------------------- }

  { Date of first marriage }
  everUnion = ( A701 in 1,2 | A702 in 1,2 );
  chadj = 1;                    { Adjustment for children in event table }
  if everUnion then              
    chadj = 2;                  // added to line number of child          
    nevents = nevents + 1;
    ismonth = valid(A715M);
    isyear  = validyr(A715Y);
    isage   = valid(A716);
    if ismonth then
      smonth(2) = A715M;
    else
      smonth(2) = 0;
    endif;
    recode isyear :: ismonth :: isage -> flag;
                1 ::       1 ::       -> 1;
                  ::       1 ::     1 -> 2;
                1 ::         ::     1 -> 3;
                1 ::         ::       -> 5;
                  ::         ::     1 -> 6;
                  ::       1 ::       -> 7;
                  ::         ::       -> 8;
    endrecode;
    sflag(2)   = flag;
    errflag(2) = notappl;
    type(2)    = 2;
    { No year of marriage given, check if age given }
    if flag in 7,8 then
      if run1 then errmsg( 5135, A716, A715M, A715Y ) endif;
    endif;

    { Initial ranges for date  of marriage }
    if validyr(A715Y) then
      lcmcm = setlb( A715M, A715Y, 0 );
      ucmcm = setub( A715M, A715Y, 9999 );
      if ucmcm > di then ucmcm = di endif;
    else
      lcmcm = lcmcb + minam;
      ucmcm = di;
    endif;

{ --------------------------------------------------------------------------- }

    { Adjust ranges for date of marriage based on age at marriage }
    if valid(A716) then

      { Adjust functions used with dates upside down to allow   }
      { adjustment of date of marriage based on age at marriage }
      { rather than adjusting date of birth                     }
      t = adjuba( di-ucmcm, di-lcmcm, di-ucmcb, di-lcmcb, A716 );
      if t < 0 then
        errmsg( 5132, A716, A715M, A715Y, AINTM, AINTY, A111, A110M, A110Y );
        errflag(2) = default;
      else
        lcmcm = di-t;
      endif;
      t = ndjlba( di-ucmcm, di-lcmcm, di-ucmcb, di-lcmcb, A716 );
      if t < 0 then
        errmsg( 5132, A716, A715M, A715Y, AINTM, AINTY, A111, A110M, A110Y );
        errflag(2) = default;
      else
        ucmcm = di-t;
      endif;

{ --------------------------------------------------------------------------- }

    { Adjust ranges for date of birth based on age at marriage }
      if errflag(2) <> default then
        t = ndjlba( lcmcb, ucmcb, lcmcm, ucmcm, A716 );
        if t < 0 then
          errmsg( 5132, A716, A715M, A715Y, AINTM, AINTY, A111, A110M, A110Y );
          errflag(2) = default;
        else
          lcmcb = t;
        endif;
        t = adjuba( lcmcb, ucmcb, lcmcm, ucmcm, A716 );
        if t < 0 then
          errmsg( 5132, A716, A715M, A715Y, AINTM, AINTY, A111, A110M, A110Y );
          errflag(2) = default;
        else
          ucmcb = t;
        endif
      endif

    endif;

    { Check date of marriage not after date of interview }
    if lcmcm > di then
      errmsg( 5130, A716, A111, AINTM, AINTY, A110M, A110Y, A715M, A715Y );
      errflag(2) = default;
    elseif ucmcm > di then
      ucmcm = di
    endif;

{ --------------------------------------------------------------------------- }

    { For month only without year, make adjustment }
    if ismonth & !isyear then
      x = int((lcmcm - 1)/12) * 12 + smonth(2);
      if x < lcmcm then
        x = x + 12
      endif;
      if x > ucmcm then
        errmsg( 5126, smonth(2), lcmcm, ucmcm, cmc2m(lcmcm), cmc2y(lcmcm), cmc2m(ucmcm), cmc2y(ucmcm) );
      else
        lcmcm = x
      endif;
      x = int((ucmcm - 1)/12) * 12 + smonth(2);
      if x > ucmcm then
        x = x - 12
      endif;
      if x < lcmcm then
        errmsg( 5126, smonth(2), lcmcm, ucmcm, cmc2m(lcmcm), cmc2y(lcmcm), cmc2m(ucmcm), cmc2y(ucmcm) );
      else
        ucmcm = x
      endif;
    endif;

{ --------------------------------------------------------------------------- }

    { Adjust for minimum age at marriage }
    t = adjlbi( lcmcb, ucmcb, lcmcm, ucmcm, minam );
    if t < 0 then
      if run1 then errmsg( 5121, int(minam/12), A110M, A110Y, A111, A715M, A715Y, A716 ) endif;
      errflag(2) = default;
    else
      lcmcm = t;
    endif;

    { Check date of marriage not after date of interview }
    if lcmcm > di then
      errmsg( 5120, A715M, A715Y, A716, AINTM, AINTY, A110M, A110Y, A111 );
      errflag(2) = default;
    elseif ucmcm > di then
      ucmcm = di
    endif;

    { Use age at first sex as lower bound for date of marriage if no info. }
    if valid(A722) & A722 <> 0 & A722 <= maxai then
      t = adjlbi( lcmcb, ucmcb, lcmcm, ucmcm, A722*12 );
      if t < 0 then
        if !ver100 then errmsg( 5193, A722, A715M,A715Y, A716, A110M,A110Y ) endif;
        kount(26) = kount(26) + 1;
        fsexflag = 6;
      else
        lcmcm = t
      endif
    endif;

    lcmc(2) = lcmcm;
    ucmc(2) = ucmcm;
    interv(2) = minam;
    cdelay(2) = 0;

  endif;

  { !!! next two instructions are necessary for DHS and MIS surveys }
  lcmc(1) = lcmcb;   
  ucmc(1) = ucmcb;
  
  { date of current marriage for women married more than once }  
  if InUnion & A714 = 2 then    
    ismonth = valid(A719M);
    isyear  = validyr(A719Y);
    isage   = valid(A720);
    if ismonth then
      cusmonth = A719M;
    else
      cusmonth = 0;
    endif;
    recode isyear :: ismonth :: isage -> flag;
                1 ::       1 ::       -> 1;
                  ::       1 ::     1 -> 2;
                1 ::         ::     1 -> 3;
                1 ::         ::       -> 5;
                  ::         ::     1 -> 6;
                  ::       1 ::       -> 7;
                  ::         ::       -> 8;
    endrecode;
    cusflag   = flag;
    cuerrflag = notappl;
    { No year of marriage given, check if age given }
    if flag in 7,8 then
      if run1 then errmsg( 5145, A720, A719M, A719Y ) endif;
    endif;

    { Initial ranges for date  of marriage }
    if validyr(A719Y) then
      lcmcm = setlb( A719M, A719Y, 0 );
      ucmcm = setub( A719M, A719Y, 9999 );
      if ucmcm > di then ucmcm = di endif;
    else
      lcmcm = lcmc(2) + min2m;
      ucmcm = di;
    endif;

{ --------------------------------------------------------------------------- }

    { Adjust ranges for date of marriage based on age at marriage }
    if valid(A720) then

      { Adjust functions used with dates upside down to allow   }
      { adjustment of date of marriage based on age at marriage }
      { rather than adjusting date of birth                     }
      t = adjuba( di-ucmcm, di-lcmcm, di-ucmcb, di-lcmcb, A720 );
      if t < 0 then
        errmsg( 5142, A720, A719M, A719Y, AINTM, AINTY, A111, A110M, A110Y );
        cuerrflag = default;
      else
        lcmcm = di-t;
      endif;
      t = ndjlba( di-ucmcm, di-lcmcm, di-ucmcb, di-lcmcb, A720 );
      if t < 0 then
        errmsg( 5142, A720, A719M, A719Y, AINTM, AINTY, A111, A110M, A110Y );
        cuerrflag = default;
      else
        ucmcm = di-t;
      endif;

    endif;

    { Check date of marriage not after date of interview }
    if lcmcm > di then
      errmsg( 5140, A720, A111, AINTM, AINTY, A110M, A110Y, A719M, A719Y );
      cuerrflag = default;
    elseif ucmcm > di then
      ucmcm = di
    endif;

{ --------------------------------------------------------------------------- }

    { For month only without year, make adjustment }
    if ismonth & !isyear then
      x = int((lcmcm - 1)/12) * 12 + cusmonth;
      if x < lcmcm then
        x = x + 12
      endif;
      if x > ucmcm then
        errmsg( 5146, smonth(3), lcmcm, ucmcm, cmc2m(lcmcm), cmc2y(lcmcm), cmc2m(ucmcm), cmc2y(ucmcm) );
      else
        lcmcm = x
      endif;
      x = int((ucmcm - 1)/12) * 12 + smonth(3);
      if x > ucmcm then
        x = x - 12
      endif;
      if x < lcmcm then
        errmsg( 5146, smonth(3), lcmcm, ucmcm, cmc2m(lcmcm), cmc2y(lcmcm), cmc2m(ucmcm), cmc2y(ucmcm) );
      else
        ucmcm = x
      endif;
    endif;

{ --------------------------------------------------------------------------- }

    { Adjust for minimum age at marriage }
    t = adjlbi( lcmcb, ucmcb, lcmcm, ucmcm, minam );
    if t < 0 then
      if run1 then errmsg( 5141, int(minam/12), A110M, A110Y, A111, A719M, A719Y, A720 ) endif;
      cuerrflag = default;
    else
      lcmcm = t;
    endif;

    { Check date of marriage not after date of interview }
    if lcmcm > di then
      errmsg( 5143, A719M, A719Y, A720, AINTM, AINTY, A110M, A110Y, A111 );
      cuerrflag = default;
    elseif ucmcm > di then
      ucmcm = di
    endif;

    if lcmcm < lcmc(2) | ucmcm < ucmc(2) then
      errmsg( 5144, A715M, A715Y, A716, A719M, A719Y, A720 );
    endif;

  endif;

{ --------------------------------------------------------------------------- }

  { Time of interview }
  if AVISITS = 1 then
    if valid(A101H) & valid(A1116H) then
      if A101H > A1116H then
        errmsg( 8110, A101H, A101M, A1116H, A1116M );
      elseif A101H = A1116H then
        if valid(A101M) & valid(A1116M) & A101M > A1116M then
          errmsg( 8110, A101H, A101M, A1116H, A1116M );
        endif
      endif
    endif
  endif;

  { Total pregnancy outcomes }
  Totpreg = A212W;

  { Check to ensure that all children listed in HH are listed in pregnancy history }
  for i in ccHH80.AHSEC01 do
    if AH13 = ALINE & count(AWSEC2B_EDT where A227 = i) <> 1 then
      errmsg( 2185, i, strip(AH02(i)) )
    endif;
  enddo;

{ --------------------------------------------------------------------------- }
{ pregnancy history }
PROC AWSEC2B_EDT

  for i in $ do
    j = A227;
    if valid(j) & j <> 0 then
      if persline(j) then
        errmsg( 2200, i, persline(j), mothline(j) );
      else
        persline(j) = j;
        mothline(j) = ALINE;
      endif;
    endif;
  enddo;

  { pregnancy history }
  for i in $ do
    nevents    = nevents + 1;
    j          = nevents;
    type(j)    = 3;
    norder(j)  = i;
    twincode(j)= 0;
    surv(j)    = A224;
	if A223 <> 1 then surv(j) = 3 endif; 
    deathl(j)  = 0;
    deathu(j)  = 0;
    durmeth(j) = 0;
    flagmeth(j)= 0;
    smonth(j)  = 0;
    calrow(j)  = 0;
	pregdur(j) = A221DUR;
	minpd      = A221DUR;  // minimum pregnancy duration
	

    isyear = 0; ismonth = 0; isage = 0; isday = 0;
    if valid(A220M) then
      smonth(j) = A220M;
      ismonth = 1
    endif;
   { Initialize logical ranges for date of birth of child }
    if validyr(A220Y) then
      isyear = 1;
      lcmc(j) = setlb( A220M, A220Y, 0 );
      ucmc(j) = setub( A220M, A220Y, 9999 );
    else
      lcmc(j) = mindb + minab;
	  numeric preglow;
      numeric insec4  = count(AWSEC04_EDT where A404 = i);   { pregnancy in section 4, impute inside postnatal care }
      numeric insec61 = count(AWSEC6A_EDT where A603 = i);   { Birth in section 6.1, impute inside health section window }
      numeric insec62 = ( soccurs(AWSEC6B) & A635 = i );     { Birth in section 6.2, impute intside nutrition }
      recode insec62 :: insec4 :: insec61 -> preglow;
		        1    ::        ::         -> birth23;
		             ::   1    ::         -> preg35;
		             ::        ::     1   -> birth59;
		             ::        ::         -> 0;
      endrecode;
	  if preglow then
        lcmc(j) = di - preglow;
      endif;
      ucmc(j) = di;
    endif;
    isday = ( A220D in 1:31 );
    if valid(A225) then
      isage = 1;
    endif;

    recode isyear :: ismonth :: isday :: isage -> flag;
                1 ::       1 ::     1 ::       -> 0;
                1 ::       1 ::       ::       -> 1;
                  ::       1 ::       ::     1 -> 2;
                1 ::         ::       ::     1 -> 3;
                1 ::         ::       ::       -> 5;
                  ::         ::       ::     1 -> 6;
                  ::       1 ::       ::       -> 7;
                  ::         ::       ::       -> 8;
    endrecode;
    if ignorey & flag = 3 & A220Y + A225 = AINTY then
      flag = 4;
      lcmc(j) = mindb + minab;
      ucmc(j) = di;
    endif;
    sflag(j)   = flag;
    errflag(j) = notappl;

{ --------------------------------------------------------------------------- }

    do k = 1 while k <= noccurs(ccHH80.ABSEC01)	{ children's hgt/wgt sect in HH }
      if AB102(k) = A227 then
        if A220Y <> AB103Y(k) | A220M <> AB103M(k) | A220D <> AB103D(k) then
          errmsg( 2212, i, A227, A220D, A220M, A220Y, AB103D(k), AB103M(k), AB103Y(k) )
        endif;
      endif;
    enddo;

    { Set up twin code variable coded as follows:
      0 - Single birth
      1 - 1st of multiple
      2 - 2nd of multiple
      3 - 3rd of multiple
      etc.
      This variable easier to use in controlling twins.
    }

    if A215 = 1 then         { Single pregnancy }
      twincode(j) = 0
    elseif A215L = 1 then     { First pregnancy }
      twincode(j) = 1
    else
      twincode(j) = twincode(j-1) + 1
    endif;

    { Update twin code variable in case of two pairs of twins together      }
    { Twincode is: 0-Single pregnancy, 1-1st of multiple, 2-2nd of multiple }
    if A215 in 2:5 & i > 2 & twincode(j-1) >= 2 then
      if (A220Y <> A220Y(i-1) | A220M <> A220M(i-1)) then
        twincode(j) = 1
      endif
    endif;

{ --------------------------------------------------------------------------- }

    { Adjust ranges for date of birth of child based on age of child }
    if A224 = 1 then
      { Living children }
      if valid(A225) then
        { Lower bound of CMC date of birth }
        t = ndjlba( lcmc(j), ucmc(j), di, di, A225 );
        if t < 0 then
          errmsg( 2171, i, strip(A218), A225, A220M, A220Y, AINTM, AINTY );
          errflag(j) = default;
        else
          lcmc(j) = t;
        endif;
        { Upper bound of CMC date of birth }
        t = adjuba( lcmc(j), ucmc(j), di, di, A225 );
        if t < 0 then
          errmsg( 2171, i, strip(A218), A225, A220M, A220Y, AINTM, AINTY );
          errflag(j) = default;
        else
          ucmc(j) = t;
        endif;
        x = di - (A225*12 + 11);
        if lcmc(j) < x & x <= ucmc(j) then
          lcmc(j) = x
        endif;
        if age_day_check(A220D, A220M, A220Y, AINTD, AINTM, AINTY, A225) > 0 then
          errmsg(2175, i, strip(A218), A225, A220D, A220M, A220Y);
        endif;
      endif;

    elseif A224 = 2 then

      { Children who have died }
      agedu = A228U;         { age at death - units }
      agedn = A228N;         { age at death - number }

      { Check maximum and minimum values }
      recode agedu -> maxd;
                 1 -> 30;       { 0-30 days   }
                 2 -> 23;       { 1-23 months }
                 3 -> 40;       { 2-40 years  }
                   -> 99;
      endrecode;
      mind = agedu-1;
      if agedu = 9 then agedu = 0 endif;
      if !agedn in mind:maxd then
        if run1 then errmsg( 2191, i, strip(A218), agedn, mind, maxd, agedu ) endif;
        flagdth(i+chadj) = 6;
      endif;

      { Check age at death plausible considering date of birth }
      recode agedu:: agedn   -> aged;
                  :: missing -> 999;
                  :: >= 97   -> 999;
                1 ::         -> int(agedn/30);
                2 ::         -> agedn;
                3 ::         -> agedn*12;
                  ::         -> 999;
      endrecode;
      if aged <> 999 then
        if lcmc(j) + aged > di then
          if run1 then errmsg( 2192, i, strip(A218), A228U, A228N, A220M, A220Y, AINTM, AINTY ) endif;
          errflag(j) = default;
          flagdth(j) = 1;
        elseif ucmc(j) + aged > di then
          ucmc(j) = di - aged
        endif;
        { Now make age at death as late as possible for those with }
        { age at death reported in years                           }
        deathl(j) = aged;               { lower limit of age at death }
        deathu(j) = aged;               { upper limit of age at death }
        if agedu = 3 then               { Age at death reported in years }
          deathu(j) = aged + 11;
          if flagdth(j) = 0 & lcmc(j) + deathu(j) > di then
            deathu(j) = di - lcmc(j)
          endif;
        endif
      else
        deathl(j) = 0;
        deathu(j) = di - lcmc(j);
      endif
    endif;

{ --------------------------------------------------------------------------- }

    { For month only without year, make adjustment }
    if ismonth & !isyear then
      x = int((lcmc(j) - 1)/12) * 12 + smonth(j);
      if x < lcmc(j) then
        x = x + 12
      endif;
      if x > ucmc(j) then
        if run1 then
          errmsg( 2172, i, strip(A218), smonth(j), lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)), cmc2m(ucmc(j)), cmc2y(ucmc(j)) )
        endif;
      else
        lcmc(j) = x
      endif;
      x = int((ucmc(j) - 1)/12) * 12 + smonth(j);
      if x > ucmc(j) then
        x = x - 12
      endif;
      if x < lcmc(j) then
        if run1 then
          errmsg( 2172, i, strip(A218), smonth(j), lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)), cmc2m(ucmc(j)), cmc2y(ucmc(j)) )
        endif;
      else
        ucmc(j) = x
      endif;
    endif;

{ --------------------------------------------------------------------------- }

    { Check first birth not before age at first sex }
    if i = 1 then
      if valid(A722) & A722 <> 0 & A722 <= maxai then
        t = adjlbi( lcmc(1), ucmc(1), lcmc(j), ucmc(j), A722*12+pregdur(j) );
        if t < 0 then
          if !ver100 then errmsg( 5191, A722, A220M, A220Y, A110M, A110Y )endif;
          kount(24) = kount(24) + 1;
          fsexflag = 3;
          t = adjlbi( lcmc(1), ucmc(1), lcmc(j), ucmc(j), (A722-1)*12+pregdur(j) );
          if t < 0 then
            fsexflag = 2
          endif
        else
          lcmc(j) = t;
        endif
      { Check minimum birth interval after marriage }
      elseif A722 = 95 & everUnion then
        t = adjlbi( lcmc(2), ucmc(2), lcmc(j), ucmc(j), pregdur(j) );
        if t < 0 then
          if !ver100 then errmsg( 5194, A722, A715M, A715Y, A220M, A220Y, A716 ) endif;
          kount(27) = kount(27) + 1;
          fsexflag = 5;
        else
          lcmc(j) = t;
        endif
      endif
    endif;

{ --------------------------------------------------------------------------- }

    { Set minimum intervals }
    cdelay(j) = 0;
    if twincode(j) > 1 then
      interv(j) = 0;
    else
      if i = 1 then             { first birth }
        if j = 3 then           { woman ever married }
          interv(j) = 0
        else                    { woman never married }
          interv(j) = minab
        endif
      else                      { subsequent births }
        interv(j) = pregdur(j); { minimum pregnancy duration }
        cdelay(j) = mincd;      { minimum conception delay }
      endif
    endif;

{ --------------------------------------------------------------------------- }

    if !special(A227) & A227 > 0 then
      { check for duplicate household line number }
      if count(AWSEC2B_EDT where A227 = A227(i) & A215L <> A215L(i)) then
        errmsg( 2184, i, strip(A218), A227, strip(AH02(A227)) );
      endif;

      { Check mother's line number agrees with line number of mother in household questionnaire }
      if AH12(A227) <> notappl & AH13(A227) <> ALINE then
        errmsg( 2182, i, strip(A218), A227, strip(AH02(A227)), AH13(A227), ALINE );
      endif;

      { Check sex of child against sex in household questionnaire }
      if A219 <> AH04(A227) then
        errmsg( 2141, i, strip(A218), A227, strip(AH02(A227)), A219, AH04(A227) );
      endif;

      { Check age of child against age in household questionnaire }
      if valid(A225) & valid(AH07(A227)) then
        x = A225 - AH07(A227);
        if !x in (-1):1 then
          errmsg( 2173, i, strip(A218), A225, AH07(A227), A227, strip(AH02(A227)) );
        endif
      endif;

      { Check living status of child against status in household questionnaire }
      if AH05(ALINE) = 1 & A226 <> AH05(A227) |
         A226 = 1 & AH05(ALINE) <> AH05(A227) then
        errmsg( 2183, i, strip(A218), A226, AH05(A227), A227, strip(AH02(A227)), AH05(ALINE) );
      endif;
    endif;

    { if mother is de jure and child lives with mother, child must have line number in HH }
    if AH05(ALINE) = 1 & A226 = 1 & A227 = 0 then
      errmsg( 2186, i, strip(A218), A227, AH05(ALINE), A226 )
    endif;

  enddo;

{ --------------------------------------------------------------------------- }
{ Calendar }

PROC AWSEC2C_EDT
{ Calendar variables :
  ACAL      - calendar itself
  calend    - end of calendar date in CMC
  calbeg    - beginning of calendar date in CMC
  callen    - length of calendar in rows
  calint    - row for date of interview i.e. top row to use for this case
  calrow(b) - row of calendar relating to birth b in birth history
  calpreg   - pregnant in month of interview, according to calendar
  caluse    - row of last use of any contraceptive method
}

{ -------------------------------------------------------------------------- }

  { Check column 1 }
  { -------------- }
  ouse    = 0;                    { Use in open interval/last closed interval }
  fuse    = 0;                    { First use of method in interval }
  luse    = 0;                    { Last  use of method in interval }
  pregs5  = 0;
  b       = Totpreg + chadj;          { Index into event table for child }
  termin  = 0;
  colw    = 1;
  calw    = ACAL(1);
  do i = calint while i <= callen

    { Check pregnancies in calendar matches pregnancies in pregnancy history }
    if calw[i:1] in codeb,codet then
      pregs5 = pregs5 + 1;
      if twincode(b) then
        pregs5 = pregs5 + twincode(b) - 1;
      endif;
      calcmc = rowcmc(i);
      if type(b) = 3 & calcmc in lcmc(b):ucmc(b) then
        calrow(b) = i;
        lcmc(b) = calcmc;
        ucmc(b) = calcmc;
      else
        errmsg( 9802, i, calcmc, cmc2m(calcmc), cmc2y(calcmc), b, type(b), lcmc(b),
                      ucmc(b), cmc2m(lcmc(b)), cmc2y(lcmc(b)), cmc2m(ucmc(b)), cmc2y(ucmc(b)));
        errflag(b) = default;
      endif;

      { Check gestation lengths of pregnancies in months }
      do j = i+1 while j <= callen & calw[j:1] = codep enddo;
	  numeric lenpreg = i + pregdur(b);
      if j > lenpreg | j <= callen & j < lenpreg then
        errmsg( 9803, i, j-i );
        errflag(b) = default;
      endif;

      { Set duration of contraceptive use }
      if luse then
        luse = fuse - luse + 1
      endif;
      if b = Totpreg + chadj then
        ouse = luse;
      else
        durmeth(b+1) = luse
      endif;
      luse = 0;
      fuse = 0;

      { Set same calrow for twins of pregnancy }
      while twincode(b) > 1 do
        calrow(b-1) = calrow(b);
        b = b - 1;
      enddo;
      b = b - 1;

    { Check pregnancy codes are either for current pregnancy, }
    { or for pregnancies that are terminated }
    elseif calw[i:1] = codep then
      if i > 1 & !pos(calw[i-1:1],concat(" ",pregstr)) then
        errmsg( 9818, i );
      endif

    { Get duration of contraceptive use }
    elseif pos(calw[i:1],strip(calmeth)) then
      if !luse then
        luse = i;
      endif;
      fuse = i;

    endif;
  enddo;

  { Check all births since January 201? are represented in calendar }
  do b = Totpreg + chadj while b > chadj by (-1)
    if lcmc(b) >= calbeg & calrow(b) = 0 then
      errmsg( 9804, b-chadj, lcmc(b), ucmc(b), cmc2m(lcmc(b)), cmc2y(lcmc(b)), cmc2m(ucmc(b)), cmc2y(ucmc(b)) )
    endif;
  enddo;

{ -------------------------------------------------------------------------- }

  { Check column 2 }
  { -------------- }
  discont = 0;              { Number of discontinuations }
  caluse = 0;               { Last use of contraception in calendar }
  xusing = default;         { Whether using in month i-1 }
  colw = 2;
  calw = "";
  if totocc( AWSEC2C_EDT ) >= 2 then
    calw = ACAL(2);
  endif;
  do i = calint while i <= callen

    { Checks for discontinuation of use, but col 2 blank }
    used = pos(ACAL(1)[i:1],strip(calmeth));    { Whether using in month i }
    if used & xusing <> used & xusing <> default then
      discont = discont + 1;
      if calw[i:1] = " " then
        errmsg( 9805, colw, i, ACAL(1)[i:1], i-1, ACAL(1)[i-1:1] );
      elseif i < callen & calw[i+1:1] <> " " then
        if run1 then errmsg( 9806, calw[i:1], calw[i+1:1], i, i+1 ) endif;
      endif;
    endif;
    xusing = used;
    if used & !caluse then
      caluse = i
    endif;

    { Checks for col 2 not blank, but no contraceptive method }
    if calw[i:1] <> " " & !used then
      errmsg( 9807, colw, i, calw[i:1] )
    endif;

    { Became pregnant while using }
    if calw[i:1] = "1" &
      ( i = calint | !ACAL(1)[i-1:1] in codep,codet ) then
      errmsg( 9812, colw, calw[i:1], i );
    endif;

    { Stopped to become pregnant }
    if AESEC4 & calw[i:1] = "2" then
      if i > calint & !pos(ACAL(1)[i-1:1],concat("0",codep)) then
        errmsg( 9813, colw, calw[i:1], i );
      endif;
      do j = i-1 while j & ACAL(1)[j:1] = "0" by (-1) enddo;
      while j & ACAL(1)[j:1] = codep do j = j - 1 enddo;
      if j & ACAL(1)[j:1] in codeb,codet then
        do b = chadj + 1 while b < Totpreg+chadj
          if AESEC4+chadj <= b & calrow(b) = j then
            n = Totpreg-norder(b)+1;	
            if n <= totocc(AWSEC04_EDT) & A408(n) <> 1 then
              if !ver100 then
                errmsg( 4050, i, norder(b), n, A408(n) );
              endif;
              kount(2) = kount(2) + 1;
            endif;
            break;
          endif;
        enddo;
      endif;
    endif;

  enddo;

{ -------------------------------------------------------------------------- }

  { Check all pregnancies are within unions - ever married samples only }
  if emsample then
    do i = calint while i <= callen
      if pos(ACAL(1)[i:1],pregstr) & calw[i:1] = "0" then
        while i <= callen & pos(ACAL(1)[i:1],pregstr) do
          i = i + 1;
        enddo;
        if calw[i-1:1] = "0" & i <= callen & calw[i:1] = "0" then
          if run1 then errmsg( 9816, i-1 ) endif
        endif
      endif;
    enddo;
  endif;

{ --------------------------------------------------------------------------- }
{ reproduction cont. }
PROC AWSEC2D_EDT

  currpregdur = 0;
  calw = ACAL(1);
  { Date of conception }
  currpreg = (A232 = 1);
  if currpreg then
    nevents = nevents + 1;
    errflag(nevents) = notappl;
    smonth(nevents) = 0;
	currpregdur = A233N;
	if A233U = 1 then currpregdur = int(A233N*WeeksMonth); endif;
	if valid(A233N) then
      sflag(nevents) = 7;
      lcmc (nevents) = di-currpregdur;
      ucmc (nevents) = di-currpregdur;
    else
      sflag(nevents) = 8;
      lcmc (nevents) = di - 9;
      ucmc (nevents) = di;
    endif;
    norder(nevents) = Totpreg+1;
    type  (nevents) = 4;
    interv(nevents) = 0;
    if Totpreg then
      cdelay(nevents) = mincd   { minimum conception delay after last birth }
    else
      cdelay(nevents) = 0
    endif;
    durmeth(nevents) = ouse;
    ouse = 0;
  endif;

{ -------------------------------------------------------------------------- }

  { Check to see if pregnant in month of interview in calendar }
  calpreg = ( calw[calint:1] = codep );
  if calpreg <=> !currpreg then
    errmsg( 2270, A232, calw[calint:1] );
  endif;

  { Check duration of current pregnancy agrees on questionnaire and calendar }
  if currpreg then
    do i = calint while i <= callen & calw[i:1] = codep enddo;
    x = i-calint;
    if currpregdur <> x then
      errmsg( 2280, x, A233U, A233N );
      if A233N = missing then
        lcmc(nevents) = di-x;
        ucmc(nevents) = di-x;
      endif
    endif
  endif;

{ -------------------------------------------------------------------------- }

  { Check response "before last pregnancy" given only when had one or more pregnancies }
  if A236N = 95 & Totpreg = 0 then
    if !ver100 then errmsg( 2360, A236U, A236N, Totpreg ) endif;
    kount(1) = kount(1) + 1;
    lperflag = 4;
  endif;

  { Period not returned since pregnancy in the last 3 years }
  if AESEC4 then
    if A476(1) = 2 & A236N <> missing & A236N < 94 |
       A476(1) = 1 & A236N = 95 then
      if !ver100 then errmsg( 2362, A476(1), A236U, A236N ) endif;
      kount(12) = kount(12) + 1;
    endif;
  endif;

{ --------------------------------------------------------------------------- }
{ Contraceptive Practice }
PROC AWSEC3B_EDT

  { Check current use and current pregnancy not both occurring }
  curruser = (A307N <> notappl);
  if currpreg & curruser then
    errmsg( 3143, A232, strip(A307) );
  endif;

  { Check current method with method use in table }
  do x = 1 while x <= length( strip(A307) )
    xmeth = pos(A307[x:1],strip(curmethw));
    if A301(xmeth) <> 1 then                     { methods should be known }
      errmsg( 3142, GetLabel(A307, A307[x:1]) );
    endif;
  enddo;

  { Check current method with method given in calendar }
  if ACAL(1)[calint:1] <> codeb then
    t = pos(ACAL(1)[calint:1],strip(calmeth));
    m = pos(A307[1:1],strip(curmethw));
    if t <> m then
      errmsg( 3131, strip(A307), ACAL(1)[calint:1] );
    endif;
  endif;

  { Numeric code for highest ranking method }
  xmeth = pos(A307[1:1], strip(curmethw));
  if xmeth = methoth then
    xmeth = 95
  elseif xmeth = methoth+1 then
    xmeth = 96
  elseif xmeth = 0 then
    xmeth = notappl
  endif;
  if xmeth <> A307N then
    errmsg( 3145, A307N, xmeth );
  endif;

  { Check current use of a method agrees with calendar }
  if (!curruser & caluse =  calint) |
     ( curruser & caluse <> calint & (lcmc(Totpreg+chadj) <> di | !pos("A",A307))) then
    errmsg( 3130, A303, strip(A307), caluse );
  elseif curruser then
    x = A307N;
    if x = 95 then
      x = methoth
    elseif x = 96 then
      x = methoth+1
    endif;
    if x <> pos(calw[calint:1],strip(calmeth)) then
      errmsg( 3140, strip(A307), calw[calint:1] );
    endif
  endif;

{ -------------------------------------------------------------------------- }

  { Date of start of use of contraceptive method }
  if NAtoZero(A307N) <> 0 then
    nevents = nevents + 1;
    sflag(nevents) = notappl;
    errflag(nevents) = notappl;
    smonth(nevents) = 0;
    isyear = 0; ismonth = 0;
    if valid(A313M) then
      smonth(nevents) = A313M;
      ismonth = 1
    elseif valid(A314M) then
      smonth(nevents) = A314M;
      ismonth = 1
    endif;
    if validyr(A313Y) then
      isyear = 1;
      lcmc(nevents) = setlb( A313M, A313Y, 0 );
      ucmc(nevents) = setub( A313M, A313Y, 9999 );
    elseif validyr(A314Y) then
      isyear = 1;
      lcmc(nevents) = setlb( A314M, A314Y, 0 );
      ucmc(nevents) = setub( A314M, A314Y, 9999 );
    else
      lcmc(nevents) = lcmc(nevents-1);
      ucmc(nevents) = di;
    endif;
    interv(nevents) = 0;
    { male sterilization can be upto 9 months before birth }
    if A307N = stermetm then interv(nevents) = (-pregdur(nevents-1)) endif;
    cdelay(nevents) = 0;
    type(nevents)   = 5;
    surv(nevents)   = A307N;             { Method currently being used }
    recode isyear :: ismonth -> flag;
                1 ::       1 -> 1;
                1 ::         -> 5;
                  ::       1 -> 7;
                  ::         -> 8;
    endrecode;
    sflag(nevents) = flag;

{ -------------------------------------------------------------------------- }

    { For month only without year, make adjustment }
    j = nevents;
    if ismonth & !isyear then
      x = int((lcmc(j) - 1)/12) * 12 + smonth(j);
      if x < lcmc(j) then
        x = x + 12
      endif;
      if x > ucmc(j) then
        if run1 then
          errmsg( 3217, smonth(j), lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)),
                        cmc2m(ucmc(j)), cmc2y(ucmc(j)) );
        endif;
      else
        lcmc(j) = x
      endif;
      x = int((ucmc(j) - 1)/12) * 12 + smonth(j);
      if x > ucmc(j) then
        x = x - 12
      endif;
      if x < lcmc(j) then
        if run1 then
          errmsg( 3217, smonth(j), lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)),
                        cmc2m(ucmc(j)), cmc2y(ucmc(j)) );
        endif;
      else
        ucmc(j) = x
      endif;
    endif;

{ -------------------------------------------------------------------------- }

    { Set alpha method code from current method and find first date }
    { used method in calendar                                       }
    x = A307N;
    if x = 95 then
      x = methoth
    elseif x = 96 then
      x = methoth + 1
    endif;
    onemeth = calmeth[x:1];
    do i = calint while i <= callen & pos(calw[i:1], onemeth) enddo;
    x = rowcmc(i) + 1;
    y = x;
    if i <= callen & calw[i:1] in codeb,codet then
      y = x - 1
    endif;

    { Check date started current use of methods with calendar }
    if ( i <= callen & (lcmc(nevents) > x | ucmc(nevents) < y) ) |
       ( i >  callen &  lcmc(nevents) > calbeg ) then
      errmsg( 3211, A314M, A314Y, lcmc(nevents), ucmc(nevents), x, y,
                    cmc2m(x), cmc2y(x), cmc2m(y), cmc2y(y), i-1 );
      errflag(nevents) = default;
    elseif i <= callen then
      if lcmc(nevents) < y then
        lcmc(nevents) = y
      endif;
      if ucmc(nevents) > x then
        ucmc(nevents) = x
      endif
    else
      if ucmc(nevents) > calbeg then
        ucmc(nevents) = calbeg
      endif
    endif;

    if onemeth = edit("9",stermeth) | onemeth = edit("9",stermetm) then
      { Look for prior use of same sterilization method, or  prior use }
      { of female sterilization if currently using male sterilization  }
      do i = i + 1 while i <= callen & !calw[i:1] in onemeth,edit("9",stermeth) enddo;
      if i <= callen then
        errmsg( 3212, i, rowcmc(i), cmc2m(rowcmc(i)), cmc2y(rowcmc(i)) );
      endif;
    endif;

{ -------------------------------------------------------------------------- }

    { Check sterilization after date of marriage }
    if everUnion & A307N in stermeth,stermetm then
      t = adjlbi( lcmc(2), ucmc(2), lcmc(nevents), ucmc(nevents), 0 );
      if t < 0 then
        if run1 then
          errmsg( 3215, lcmc(nevents), ucmc(nevents), cmc2m(lcmc(nevents)), cmc2y(lcmc(nevents)),
                        cmc2m(ucmc(nevents)), cmc2y(ucmc(nevents)), lcmc(2), ucmc(2),
                        cmc2m(lcmc(2)), cmc2y(lcmc(2)), cmc2m(ucmc(2)), cmc2y(ucmc(2)) );
        endif;
        errflag(nevents) = default;
      else
        lcmc(nevents) = t;
      endif
    endif;

    { Check minimum age at sterilization }
    if A307N in stermeth,stermetm then
      minasx = minas;
    else
      minasx = minab;
    endif;
    t = adjlbi( lcmc(1), ucmc(1), lcmc(nevents), ucmc(nevents), minasx );
    if t < 0 then
      if run1 then
        errmsg( 3216, lcmc(nevents), ucmc(nevents), cmc2m(lcmc(nevents)), cmc2y(lcmc(nevents)),
                      cmc2m(ucmc(nevents)), cmc2y(ucmc(nevents)), int(minasx/12), lcmc(1), ucmc(1),
                      cmc2m(lcmc(1)), cmc2y(lcmc(1)), cmc2m(ucmc(1)), cmc2y(ucmc(1)) );
      endif;
      errflag(nevents) = default;
    else
      lcmc(nevents) = t;
    endif
  endif;

  { Check source of current method against method        }
  { !!! include only methods that apply to this question }
  { !!! Needs adapting to each country                   }
  recode A307N ::       A330           -> err;
               :: 98,missing,notappl   -> 0;
             3 :: 11:14,21,23:24,26    -> 0;  { IUD }
             4 :: 11:14,21:29          -> 0;  { injectables }
             5 :: 11:14,21,23:24,26    -> 0;  { implants }
             6 :: 11:19,21:29,31       -> 0;  { pill }
             7 :: 11:19,21:29,31,33,96 -> 0;  { condom }
             8 :: 11:19,21:29,31,33,96 -> 0;  { female condom }
             9 :: 11:19,21:29,31       -> 0;  { emergency contraception }
            10 :: 11:19,21:29,31,33,96 -> 0;  { standard days method }
            95 :: 11:19,21:29          -> 0;  { other modern method }
       3:10,95 ::                      -> 1;
               ::                      -> 0;
  endrecode;
  if err then
    if run1 then errmsg( 3280, A330, strip(A307) ) endif;
  endif;

{ --------------------------------------------------------------------------- }

  { Check that all methods used in calendar are known methods in contraceptive table }
  { To check on ever use against calendar change knowledge to ever use !! }
  do i = calint while i <= callen
    if pos( ACAL(1)[i:1], strip(calmeth) ) then
      m = pos( ACAL(1)[i:1], strip(calmeth) );  //one to one correspondence between calendar and contraceptive table
      if A301(m) <> 1 then
        errmsg( 9817, ACAL(1)[i:1], i, m, A301(m) );
      endif;
      { advance until the beginning of use of the episode }
      do j = i + 1 while j <= callen & ACAL(1)[i:1] = ACAL(1)[j:1]
      enddo;
      i = j - 1;
    endif;
  enddo;


{ --------------------------------------------------------------------------- }
{ pregnancy and postnatal care }
PROC AWSEC04_EDT

  for i in AWSEC04_EDT do
    ch = A404+chadj;                 { event table entry for child }

    { Check for same information for twins }
    if twincode(ch) > 1 then
      if A408 <> A408(i+1)        then errmsg( 4140, i, i+1, "A408" ,i, A408 ,"A408" ,i+1, A408(i+1) ) endif;
      if A409 <> A409(i+1)        then errmsg( 4140, i, i+1, "A409", i, A409, "A409", i+1, A409(i+1) ) endif;
      if A410 <> A410(i+1)        then errmsg( 4142, i, i+1, "A410", i, A410, "A410", i+1, A410(i+1) ) endif;
      if A434 <> A434(i+1) & run1 then errmsg( 4142, i, i+1, "A434" ,i, A434 ,"A434" ,i+1, A434(i+1) ) endif;
      if A435 <> A435(i+1) & run1 then errmsg( 4140, i, i+1, "A435" ,i, A435 ,"A435" ,i+1, A435(i+1) ) endif;
      if A436 <> A436(i+1) & run1 then errmsg( 4140, i, i+1, "A436" ,i, A436 ,"A436" ,i+1, A436(i+1) ) endif;
    endif;

    { Years ago last tetanus injection vs current age }
    { For check on "Year of last tetanus injection vs age" -> see DHS5 errmsg 4219 }
    if valid(A425) & A425 > agew then
      if run1 then errmsg( 4220, i, A425, A110M, A110Y, A111 ) endif;
    endif;

    { Still breastfeeding child that is not last or twin of last }
    if (A404 <= A212 - twincode(ch) - (twincode(ch) = 0)) & A485 = 1 then
      if !ver100 then errmsg( 4280, i, A404, A485 ) endif;
    endif;

{ --------------------------------------------------------------------------- }

    { Check time started feeding consistent with early deaths }
    if A482U = 2 & A228U(A404) = 1 &
       A228N(A404) <> missing & A228N(A404) < 96 &
       A482N <> missing & A482N > A228N(A404) then
      if !ver100 then
        errmsg( 4260, i, A482U, A482N, A404, A228U(A404), A228N(A404) );
      endif;
      if flagdth(ch) <> 1 & flagdth(ch) <> 2 then flagdth(ch) = 4 endif;
    endif;

  enddo;

{ --------------------------------------------------------------------------- }
{ Immunization and Health }
PROC AWSEC05_EDT

  { Vaccinations }
  for i in AWSEC05_EDT do

    ch = A503+chadj;            { event table entry for child }
    b  = lcmc(ch);              { lower bound of date of birth of child }
    cy = int((b-1)/12)+1900;    { year of birth of child ! modified for 4 digit date }
    cm = (b-1)%12+1;            { month of birth of child }
    cd = A220D(A503);           { day of birth of child }
    if !valid( cd ) then        { take day from biomarker section }
      do j = 1 while j <= noccurs( ccHH80.ABSEC01 )
        if AB102(j) = A227(A503) then   { found same child in H/W section }
          cd = AB103D(j);               { day of birth of child }
        endif;
      enddo;
    endif;
    if !valid( cd ) then
      cd = 0
    endif;

    { Date of death upper bound }
    if A224(A503) = 2 then              { child died }
      b = ucmc(ch)+deathu(ch);          { upper bound of date of death }
      dy = int((b-1)/12)+1900;          { year of death of child ! modified for 4 digit date }
      dm = (b-1)%12+1;                  { month of death of child }
      { age at death reported in days }
      if A228U(A503) = 1 & valid(A228N(A503)) then
        dd = cd+A228N(A503);            { day of death of child }
        while dd > 30 do                { if into next month, adjust }
          dd = dd - 30;
          dm = dm + 1;
          if dm > 12 then
            dm = 1;
            dy = dy + 1
          endif
        enddo
      else
        dd = 31;                        { day of death of child }
      endif
    endif;

    { Vaccination card exists }
    if A504 = 1 then

      { Check if it has anything on it }
      if D509B  = 0 & D509H  = 0 & 
	     D509P0 = 0 & D509P1 = 0 & D509P2 = 0 & D509P3 = 0 & D509IPV = 0 &
         D509D1 = 0 & D509D2 = 0 & D509D3 = 0 & D509D4 = 0 &
         D509N1 = 0 & D509N2 = 0 & D509N3 = 0 &
         D509R1 = 0 & D509R2 = 0 & D509R3 = 0 &
         D509M1 = 0 & D509M2 = 0 &
         D509V  = 0  then
        if run1 then errmsg( 4476, i, A504 ) endif;

      else

        lastvacy = 0; lastvacm = 0; lastvacd = 0;

        { If vaccinations are recorded - check the dates }

        do v = 1 while v <= 20

          { Loop through all of the vaccinations }

          { BCG | Hep B at birth | Pol 0 | DPT 1 | Pneumococcal 1 | rotavirus 1 | Measles 1 | Vit.A }
          if v in 1,2,3,8,12,15,18,20 then
            xy =  0; xm =  0; xd =  0;
          elseif vd > 0 then
            xy = vy; xm = vm; xd = vd; xstring = vstring;
          endif;

          if     v =  1 then vd = D509B ;  vm = M509B ;  vy = Y509B ;  vstring = "BCG"
          elseif v =  2 then vd = D509H ;  vm = M509H ;  vy = Y509H ;  vstring = tr("Hep at birth")
          elseif v =  3 then vd = D509P0;  vm = M509P0;  vy = Y509P0;  vstring = tr("Polio") + "0"
          elseif v =  4 then vd = D509P1;  vm = M509P1;  vy = Y509P1;  vstring = tr("Polio") + "1"
          elseif v =  5 then vd = D509P2;  vm = M509P2;  vy = Y509P2;  vstring = tr("Polio") + "2"
          elseif v =  6 then vd = D509P3;  vm = M509P3;  vy = Y509P3;  vstring = tr("Polio") + "3"
          elseif v =  7 then vd = D509IPV; vm = M509IPV; vy = Y509IPV; vstring = tr("Polio") + tr("IPV")
          elseif v =  8 then vd = D509D1;  vm = M509D1;  vy = Y509D1;  vstring = tr("DPT") + "1"
          elseif v =  9 then vd = D509D2;  vm = M509D2;  vy = Y509D2;  vstring = tr("DPT") + "2"
          elseif v = 10 then vd = D509D3;  vm = M509D3;  vy = Y509D3;  vstring = tr("DPT") + "3"
          elseif v = 11 then vd = D509D4;  vm = M509D4;  vy = Y509D4;  vstring = tr("DPT") + "4"
          elseif v = 12 then vd = D509N1;  vm = M509N1;  vy = Y509N1;  vstring = tr("Pneumococ") + "1"
          elseif v = 13 then vd = D509N2;  vm = M509N2;  vy = Y509N2;  vstring = tr("Pneumococ") + "2"
          elseif v = 14 then vd = D509N3;  vm = M509N3;  vy = Y509N3;  vstring = tr("Pneumococ") + "3"
          elseif v = 15 then vd = D509R1;  vm = M509R1;  vy = Y509R1;  vstring = tr("Rotavirus") + "1"
          elseif v = 16 then vd = D509R2;  vm = M509R2;  vy = Y509R2;  vstring = tr("Rotavirus") + "2"
          elseif v = 17 then vd = D509R3;  vm = M509R3;  vy = Y509R3;  vstring = tr("Rotavirus") + "3"
          elseif v = 18 then vd = D509M1;  vm = M509M1;  vy = Y509M1;  vstring = tr("Measles") + "1"
          elseif v = 19 then vd = D509M2;  vm = M509M2;  vy = Y509M2;  vstring = tr("Measles") + "2"
          elseif v = 20 then vd = D509V;   vm = M509V;   vy = Y509V;   vstring = tr("Vitamin") + "A1"
          endif;

{ --------------------------------------------------------------------------- }

          { check vaccination given before interview date }
          if vy in 0,4444,6666 then vy = 9999 endif;
          if validyr(vy) & (vy > AINTY | (vy = AINTY &
             valid  (vm) & (vm > AINTM | (vm = AINTM &
             valid  (vd) &  vd > AINTD )))) then
            errmsg( 4471, i, vstring, vd, vm, vy, AINTD, AINTM, AINTY );
            vd = 0; vm = 0; vy = 0;
          endif;

          { vaccination date should be after date of birth }
          if vy < cy | (vy = cy & (vm < cm | (vm = cm & vd < cd))) then
            errmsg( 4472, i, vstring, vd, vm, vy, cd, cm, cy );
            vd = 0; vm = 0; vy = 0;
          endif;

          { vaccination should be given before age at death }
          if A224(A503) = 2 then                     { child died }
            if validyr(vy) & (vy > dy | (vy = dy &
               valid  (vm) & (vm > dm | (vm = dm &
               valid  (vd) &  vd > dd )))) then
              errmsg( 4475, i, vstring, vd, vm, vy, dd, dm,dy );
              if flagdth(ch) = 0 | flagdth(ch) > 4 then flagdth(ch) = 5 endif;
            endif
          endif;

          { Get date of latest vaccination }
          if validyr(vy) & vy > lastvacy then
            lastvacy = vy;
            if valid(vm) then
              lastvacm = vm;
              if valid(vd) then
                lastvacd = vd;
              else
                lastvacd = 0;
              endif
            else
              lastvacm = 0;
              lastvacd = 0;
            endif
          endif;

          { Check if vaccinations given in order }
          if vd <> 0 & xd <> 0 then
            if validyr(xy) & (vy < xy | (vy = xy &
               valid  (xm) & (vm < xm | (vm = xm &
               valid  (xd) &  vd < xd )))) then
              errmsg( 4473, i, vstring, vd, vm, vy, xstring, xd, xm, xy );
            endif
          endif;

        enddo;

{ --------------------------------------------------------------------------- }

        { Check if vaccinations were given on the same day }
        { There are two ways that this may happen, depending on the country }
        { 1) BCG & P1, P2 & D1, P3 & D2 }
        { 2) BCG & Hep & P0, P1 & D1 & N1 & R1, P2 & D2 & N2 & R2, P3 & D3 & N3 & R3 <- current default !!! modify as needed }

        if ckvdate( D509B,  M509B,  Y509B,  D509H,  M509H,  Y509H  ) |
           ckvdate( D509B,  M509B,  Y509B,  D509P0, M509P0, Y509P0 ) |
           ckvdate( D509P1, M509P1, Y509P1, D509D1, M509D1, Y509D1 ) |
           ckvdate( D509P1, M509P1, Y509P1, D509N1, M509N1, Y509N1 ) |
           ckvdate( D509P1, M509P1, Y509P1, D509R1, M509R1, Y509R1 ) |
           ckvdate( D509P2, M509P2, Y509P2, D509D2, M509D2, Y509D2 ) |
           ckvdate( D509P2, M509P2, Y509P2, D509N2, M509N2, Y509N2 ) |
           ckvdate( D509P2, M509P2, Y509P2, D509R2, M509R2, Y509R2 ) |
           ckvdate( D509P3, M509P3, Y509P3, D509D3, M509D3, Y509D3 ) |
           ckvdate( D509P3, M509P3, Y509P3, D509N3, M509N3, Y509N3 ) |
           ckvdate( D509P3, M509P3, Y509P3, D509R3, M509R3, Y509R3 ) then
          if run1 then
            errmsg( 4474,i, edit("99/99/9999",vdate(D509B ,M509B ,Y509B )),
                            edit("99/99/9999",vdate(D509H ,M509H ,Y509H )),
                            edit("99/99/9999",vdate(D509P0,M509P0,Y509P0)),
                            edit("99/99/9999",vdate(D509P1,M509P1,Y509P1)),
                            edit("99/99/9999",vdate(D509D1,M509D1,Y509D1)),
                            edit("99/99/9999",vdate(D509N1,M509N1,Y509N1)),
                            edit("99/99/9999",vdate(D509R1,M509R1,Y509R1)),
                            edit("99/99/9999",vdate(D509P2,M509P2,Y509P2)),
                            edit("99/99/9999",vdate(D509D2,M509D2,Y509D2)),
                            edit("99/99/9999",vdate(D509N2,M509N2,Y509N2)),
                            edit("99/99/9999",vdate(D509R2,M509R2,Y509R2)),
                            edit("99/99/9999",vdate(D509P3,M509P3,Y509P3)),
                            edit("99/99/9999",vdate(D509D3,M509D3,Y509D3)),
                            edit("99/99/9999",vdate(D509N3,M509N3,Y509N3)),
                            edit("99/99/9999",vdate(D509R3,M509R3,Y509R3)) )
          endif;
        endif;

        if lastvacy > 0 then
          x = setub( lastvacm, lastvacy, 9999 );
          y = setlb( lastvacm, lastvacy, 0 );
          if x in lcmc(ch):ucmc(ch) then
            ucmc(ch) = x { adjust upper bound to avoid imputing after vaccination date }
          endif;

          if x - ucmc(ch) > deathu(ch) then
            x = 0; { Do nothing - message already given above (hopefully!) }
          elseif y - ucmc(ch) > deathl(ch) then
            deathl(ch) = y - ucmc(ch)
          endif;
        endif

      endif;

      { Other vaccinations reported by mother, but no others marked 66 on form }
      if A512 <> 1 <=> ( D509B  = 66 | D509H  = 66 |
                         D509P0 = 66 | D509P1 = 66 | D509P2 = 66 | D509P3 = 66 | D509IPV = 66 |
                         D509D1 = 66 | D509D2 = 66 | D509D3 = 66 | D509D4 = 66 |
                         D509N1 = 66 | D509N2 = 66 | D509N3 = 66 |
                         D509R1 = 66 | D509R2 = 66 | D509R3 = 66 |
                         D509M1 = 66 | D509M2 = 66 |
                         D509V  = 66 ) then
        if run1 then
          errmsg( 4480, i ,A512, edit("99/99/9999",vdate(D509B , M509B , Y509B )),   { bcg }
                                 edit("99/99/9999",vdate(D509H , M509H , Y509H )),
                                 edit("99/99/9999",vdate(D509P0, M509P0, Y509P0)),
                                 edit("99/99/9999",vdate(D509P1, M509P1, Y509P1)),
                                 edit("99/99/9999",vdate(D509P2, M509P2, Y509P2)),
                                 edit("99/99/9999",vdate(D509P3, M509P3, Y509P3)),
                                 edit("99/99/9999",vdate(D509IPV,M509IPV,Y509IPV)),
                                 edit("99/99/9999",vdate(D509D1, M509D1, Y509D1)),
                                 edit("99/99/9999",vdate(D509D2, M509D2, Y509D2)),
                                 edit("99/99/9999",vdate(D509D3, M509D3, Y509D3)),
                                 edit("99/99/9999",vdate(D509D4, M509D4, Y509D4)),
                                 edit("99/99/9999",vdate(D509N1, M509N1, Y509N1)),
                                 edit("99/99/9999",vdate(D509N2, M509N2, Y509N2)),
                                 edit("99/99/9999",vdate(D509N3, M509N3, Y509N3)),
                                 edit("99/99/9999",vdate(D509R1, M509R1, Y509R1)),
                                 edit("99/99/9999",vdate(D509R2, M509R2, Y509R2)),
                                 edit("99/99/9999",vdate(D509R3, M509R3, Y509R3)),
                                 edit("99/99/9999",vdate(D509M1, M509M1, Y509M1)),
                                 edit("99/99/9999",vdate(D509M2, M509M2, Y509M2)),
                                 edit("99/99/9999",vdate(D509V,  M509V,  Y509V )) ); { vitamin A }
        endif;
      endif;
    endif;
  enddo;
  
  

{ --------------------------------------------------------------------------- }
{ feeding practices for children and women }
PROC AWSEC6B_EDT
{
  { check other foods recorded and assign Yes to the proper question }
  { - For A637W }
  if pos("A",A637W) then A637A = 1 endif;
  if pos("B",A637W) then A637B = 1 endif;
  if pos("C",A637W) then A637C = 1 endif;
  if pos("D",A637W) then A637D = 1 endif;
  if pos("E",A637W) then A637E = 1 endif;
  if pos("F",A637W) then A637F = 1 endif;
  if pos("G",A637W) then A637G = 1 endif;
  if pos("H",A637W) then A637H = 1 endif;
  if pos("I",A637W) then A637I = 1 endif;
  if pos("J",A637W) then A637J = 1 endif;
  if pos("K",A637W) then A637K = 1 endif;
  if pos("L",A637W) then A637L = 1 endif;
  if pos("M",A637W) then A637M = 1 endif;
  if pos("N",A637W) then A637N = 1 endif;
  if pos("O",A637W) then A637O = 1 endif;
  if pos("P",A637W) then A637P = 1 endif;
  if pos("Q",A637W) then A637Q = 1 endif;
  if pos("Z",A637W) then A637R = 1 endif;
  { - For A639W }
  if pos("A",A639W) then A637A = 1 endif;
  if pos("B",A639W) then A637B = 1 endif;
  if pos("C",A639W) then A637C = 1 endif;
  if pos("D",A639W) then A637D = 1 endif;
  if pos("E",A639W) then A637E = 1 endif;
  if pos("F",A639W) then A637F = 1 endif;
  if pos("G",A639W) then A637G = 1 endif;
  if pos("H",A639W) then A637H = 1 endif;
  if pos("I",A639W) then A637I = 1 endif;
  if pos("J",A639W) then A637J = 1 endif;
  if pos("K",A639W) then A637K = 1 endif;
  if pos("L",A639W) then A637L = 1 endif;
  if pos("M",A639W) then A637M = 1 endif;
  if pos("N",A639W) then A637N = 1 endif;
  if pos("O",A639W) then A637O = 1 endif;
  if pos("P",A639W) then A637P = 1 endif;
  if pos("Q",A639W) then A637Q = 1 endif;
  if pos("R",A639W) then A637R = 1 endif;
  { assign number of times collected yougurt as part of A637W or A639W }
  if pos("A",A637W) | pos("A",A639W) then
    A637A = A637AW;
  endif;

  { - For A643W }
  if pos("A",A643W) then A643A = 1 endif;
  if pos("B",A643W) then A643B = 1 endif;
  if pos("C",A643W) then A643C = 1 endif;
  if pos("D",A643W) then A643D = 1 endif;
  if pos("E",A643W) then A643E = 1 endif;
  if pos("F",A643W) then A643F = 1 endif;
  if pos("G",A643W) then A643G = 1 endif;
  if pos("H",A643W) then A643H = 1 endif;
  if pos("I",A643W) then A643I = 1 endif;
  if pos("J",A643W) then A643J = 1 endif;
  if pos("K",A643W) then A643K = 1 endif;
  if pos("L",A643W) then A643L = 1 endif;
  if pos("M",A643W) then A643M = 1 endif;
  if pos("N",A643W) then A643N = 1 endif;
  if pos("O",A643W) then A643O = 1 endif;
  if pos("P",A643W) then A643P = 1 endif;
  if pos("Q",A643W) then A643Q = 1 endif;
  if pos("Z",A643W) then A643R = 1 endif;
}  
{ --------------------------------------------------------------------------- }
{ Marriage and Sexual Activity }
PROC AWSEC07_EDT
  { Checking line number of husband }

  { If line number of husband not collected in individual questionnaire,    }
  { but is collected in household questionnaire, replace A710 with variable }
  { from household schedule and move code to household schedule section.    }

  { Store respondent's line & marital status to check at level 1 postproc }
  do i = 1 while i <= maxelig & womhusb(i,1) <> ALINE & womhusb(i,1) <> 0 enddo;
  womhusb(i,1) = ALINE;
  womhusb(i,2) = A701;
  womhusb(i,3) = A710;

  trymatch = inunion;
  rw = AH03(ALINE);
  if !special(A710) & A710 <> 0 then
    trymatch = 0;
    { Check if line number is out of range }
    if A710 > AHMEMBER then
      errmsg( 5060, A710, AHMEMBER );
      trymatch = 1;
    else
      { Check partner is male }
      if AH04(A710) <> 1 then
        errmsg( 5061, AH04(A710), A710 );
        trymatch = 1;
      endif;
      { Check partner is at least age 15 }
      if AH07(A710) in 0:14 then
        errmsg( 5062, AH07(A710), A710, 15 );
        trymatch = 1;
      endif;
      rh = AH03(A710);
      recode rw :: rh                -> err;    { WIFE                  : HUSBAND             }
              1 :: 2                 -> 0;      { Head                  : Spouse              }
              2 :: 1                 -> 0;      { Spouse                : Head                }
              3 :: 4                 -> 0;      { Son/Daughter          : Son/Daughter in:law }
              4 :: 3                 -> 0;      { Son/Daughter in:law   : Son/Daughter        }
              5 :: 9                 -> 0;      { grandchild            : Other relative      }
              6 :: 6                 -> 0;      { Parent                : Parent              }
              7 :: 7                 -> 0;      { Parent in:law         : Parent in:law       }
              8 :: 9                 -> 0;      { Brother/Sister        : Other relative      }
              9 :: 5,8:11,98         -> 0;      { Other relative        : check codes         }
          10:11 :: 10:11             -> 0;      { Adopted/not related   : Adopted/not related }
     98,missing :: 10,11,98,missing  -> 0;      { Unknown               : check codes         }
                ::                   -> 1;      { Invalid relationships                       }
      endrecode;
      if err then     { Relationship not OK }
        if run1 then errmsg( 5064, rw, A710, rh ) endif;
        trymatch = 1;
      endif;

      { Check husband's age with age declared in the household } 
      if valid(AH07(A710)) & A902 <> AH07(A710) then 
        if run1 then errmsg( 5068, A710, A902, AH07(A710) ) endif; 
      endif;
    endif
  endif;

  { Head/Spouse/Daughter/Daughter-in-law/Mother/Mother-in-law -- try and find husband }
  if trymatch & rw in 1:4,6:7 then
    for j in record AHSEC01 do
      rh = AH03;
      recode rw :: rh -> rok;
              1 :: 2  -> 1;   { Head            - Spouse        }
              2 :: 1  -> 1;   { Spouse          - Head          }
              3 :: 4  -> 1;   { Daughter        - Son-in-law    }
              4 :: 3  -> 1;   { Daughter-in-law - Son           }
              6 :: 6  -> 1;   { Mother          - Father        }
              7 :: 7  -> 1;   { Mother-in-law   - Father-in-law }
                ::    -> 0;
      endrecode;
      { Found probable husband for woman }
      { if male, relationship OK }
      if AH04 = 1 & rok &
         { not daughter or daughter-in-law }
        ((rw <> 3 & rw <> 4) |
         { only daughter with son-in-law anywhere in list }
         (rw = 3 & (count( ccHH80.AHSEC01 where AH03 = 4 & AH04 = 1) = 1 |
                   { daughter with son-in-law immediately before or after }
                   j = ALINE-1 | j = ALINE+1)
         ) |
         { daughter-in-law with only one son anywhere in list }
         (rw = 4 & (count( ccHH80.AHSEC01 where AH03 = 3 & AH04 = 1) = 1 |
                   { daughter-in-law with son immediately before }
                   j = ALINE-1)
         )
        ) then
        { See if husband listed in wife's questionnaire }
        if A710 <> j then
          errmsg( 5063, j, rh, ALINE, rw )
        endif;
      endif;
    enddo;
  endif;

  { Wife rank number exceds number of wives }
  if valid(A712) & valid(A713) & A713 > A712 then
    if run1 then errmsg( 5100, A713, A712 ) endif
  endif;

  { Check age at first sex }
  if A722 <> missing & A722 <> 0 & A722 <= maxai then
    if A722 > agew then                       { Exceeds current age }
      if run1 then errmsg( 5190, A722, A111, AINTM, AINTY, A110M, A110Y ) endif;
      fsexflag = 1;
    endif
  elseif A722 = 95 & !everUnion then             { First time when married }
    if !ver100 then errmsg( 5192, A722, A702 ) endif;      { but never married }
    kount(25) = kount(25) + 1;
    fsexflag = 4;
  endif;

  if A723U = 4 and A232 in 1,8 then   { No sex in last year, but is or may be pregnant }
    errmsg( 5200, A723U, A723N, A232 )
  endif;

  { # of lifetime partners should be equal or higher than # of partners in last 12 months }
  sexp = ( A722 <> 0 ) + ( A731 = 1 ) + ( A734 = 1 ); 
  if valid(A737) & A737 < sexp then
    errmsg( 5245, sexp )
  endif;
  
  { check that method used for last sex is known in contraceptive table }
  do x = 1 while x <= length( strip(A726) )
    xmeth = pos(A726[x:1],strip(curmethw));
    if A301(xmeth) <> 1 then                     { methods should be known }
      errmsg( 3150, GetLabel(A726, A726[x:1]) );
    endif;
  enddo;

  { Use of condom and knowledge in with contraceptive table  }
  if ( A727 = 1 | A732 = 1 | A735 = 1 ) & A301(condom) <> 1 then
    errmsg( 6280, A727, A732, A735, A301(condom) );
  endif;

{ --------------------------------------------------------------------------- }
{ Fertility Preferences }
PROC AWSEC08_EDT

  { Check if response is less than 9 months for time to wait for future birth }
  if A805U = 1 & A805N < 9 then
    if run1 then errmsg( 6031, A805U, A805N ) endif;
  { wants a child after marriage but currently in union }
  elseif A805N = 95 & A701 = 1 then
    if run1 then errmsg( 6032, A805U, A805N, A701 ) endif
  endif;

  { check reasons for not planning to use a method soon }
  if !ver100 then
    { because not married, but currently married }
    if pos("A", A810) & A701 = 1 then
      errmsg( 6100, A701, "A810", strip(A810) )
    endif;
    { because in menopause/hysterectomy, but not in menopause }
    if pos("D", A810) & A236N <> 94 then
      errmsg( 6104, "A810", strip(A810), A236U, A236N )
    endif;
    { because infecund, but didn't declared that "can't get pregnant" }
    if pos("E", A810) & A804 <> 3 & A805N <> 94 then
      errmsg( 6105, "A810", strip(A810), A804, A805U, A805N )
    endif;
    { because knows no method, but knows some method }
    if pos("M", A810) & count( AWSEC31_GRP where A301 = 1 ) then
      errmsg( 6101, "A810", strip(A810), count( AWSEC31_GRP where A301 = 1 ) )
    endif;
    { because knows no source, but knows some source }
    if pos("N", A810) & A331 <> 2 then
      errmsg( 6111, "A810", strip(A810), A331 );
    endif;                                      { knows no source }
  endif;


  { ideal number of children }
  if valid(A814A) & valid(A814B) & valid(A814C) & A814C < 96 &
         A814A+A814B+A814C <> A813 then
    errmsg( 6131, A814A, A814B, A814C, A813 );
  endif;

{ --------------------------------------------------------------------------- }
{ Husband and Woman's Background, serve mainly as an anchor for imputation    }
PROC AWSEC09_EDT
  { decision on respondent earnings }
  if A919 in 2,3 & !inunion then
    errmsg( 7250, "A919", A919, A701 )
  endif;
  { decision on husband earnings }
  if A921 in 2:4 & !inunion then
    errmsg( 7250, "A921", A921, A701 )
  endif;
  { decision on respondent health care }
  if A922 in 2,3 & !inunion then
    errmsg( 7250, "A922", A922, A701 )
  endif;
  { decision on making major purchases }
  if A923 in 2,3 & !inunion then
    errmsg( 7250, "A923", A923, A701 )
  endif;
  { decision on visits to family }
  if A924 in 2,3 & !inunion then
    errmsg( 7250, "A924", A924, A701 )
  endif;
  { ownership of a house }
  if A925 in 2,4 & !inunion then
    errmsg( 7250, "A925", A925, A701 )
  endif;
  { ownership of land }
  if A928 in 2,4 & !inunion then
    errmsg( 7250, "A928", A928, A701 )
  endif;
  { presence of husband }
  if A931B in 1,2 & !inunion then
    errmsg( 7250, "A931B", A931B, A701 )
  endif;

  { Equalizing twins }
  umin = 9999;
  lmax = 0;
  ntwin = 0;
  do i = chadj+1 while i <= Totpreg+chadj
    j = i + 1;
    if special(twincode(j)) | twincode(j) <= 1 then
      if umin < lmax then
        errmsg( 9920, j-1, lmax, umin, cmc2m(lmax), cmc2y(lmax), cmc2m(umin), cmc2y(umin) )
      else
        do k = 1 while k <= ntwin
          lcmc(j-k) = lmax;
          ucmc(j-k) = umin;
        enddo;
      endif;
      umin = 9999;
      lmax = 0;
      ntwin = 0;
    endif;
    if !special(twincode(j)) & twincode(j) >= 1 then
      ntwin = ntwin + 1;
      if lcmc(j) > lmax then lmax = lcmc(j) endif;
      if ucmc(j) < umin then umin = ucmc(j) endif;
    endif;
  enddo;

{ --------------------------------------------------------------------------- }

  { Date of interview event and open birth interval }
  nevents = nevents + 1;
  lcmc(nevents)    = di;
  ucmc(nevents)    = di;
  type(nevents)    = 6;
  sflag(nevents)   = 1;
  smonth(nevents)  = 0;
  errflag(nevents) = notappl;

  if currpreg then
    interv(nevents) = mincd;
    if currpregdur <> missing & currpregdur < mincd then interv(nevents) = currpregdur endif;
  else
    interv(nevents) = 0
  endif;
  cdelay (nevents) = 0;
  durmeth(nevents) = ouse;      { Duration of use }

{ --------------------------------------------------------------------------- }

  if Totpreg then
    { forward checking of date of first birth }
    i = chadj + 1;
    t = adjlbi( lcmc(1), ucmc(1), lcmc(i), ucmc(i), minab );
    if t < 0 then
      errmsg( 9902, 1, lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)), cmc2m(ucmc(1)),
                    cmc2y(ucmc(1)), i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                    cmc2m(ucmc(i)), cmc2y(ucmc(i)), minab );
      errflag(i) = default;
    else
      lcmc(i) = t;
      { backward checking of date of first birth }
      t = adjubi( lcmc(1), ucmc(1), lcmc(i), ucmc(i), minab );
      if t < 0 then
        errmsg( 9902, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)),
                      cmc2y(ucmc(i)), 1, lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)),
                      cmc2m(ucmc(1)), cmc2y(ucmc(1)), minab );
        errflag(1) = default;
      else
        ucmc(1) = t;
      endif;
    endif;
  endif;

{ -------------------------------------------------------------------------- }

  { forward checking of minimum interval }
  do i = 1 while i <= nevents - 1
    j = i + 1;
    t = adjlbi( lcmc(i), ucmc(i), lcmc(j), ucmc(j), interv(j)+cdelay(j) );
    if t < 0 then
      if type(i) = 2 & type(j) <> 6 then
        if A722 = 95 & fsexflag = 0 then
          fsexflag = 5
        endif
      else
        x1 = type(i);
        x2 = type(j);
        recode x1 :: x2 -> eno;
                1 ::  2 -> 9901;    { Between birth and first union }
                1 ::  3 -> 9902;    { Between birth and first child }
                2 ::  3 -> 9903;    { Between union and first child }
              1,2 ::    -> 9904;    { Between birth or union and other events }
                3 ::  3 -> 9905;    { Between children }
                3 ::    -> 9906;    { Between last child and later events }
                  ::    -> 9907;    { Between other events }
        endrecode;
        if eno = 9905 then
          errmsg( eno, norder(i), i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                       cmc2m(ucmc(i)), cmc2y(ucmc(i)), norder(j), j, lcmc(j), ucmc(j),
                       cmc2m(lcmc(j)), cmc2y(lcmc(j)), cmc2m(ucmc(j)), cmc2y(ucmc(j)),
                       interv(j)+cdelay(j) );
        else
          errmsg( eno, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)),
                       cmc2y(ucmc(i)), j, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)),
                       cmc2m(ucmc(j)), cmc2y(ucmc(j)), interv(j)+cdelay(j) );
        endif;
        errflag(j) = default;
      endif;
    else
      lcmc(j) = t;
    endif;
  enddo;

{ -------------------------------------------------------------------------- }

  { backward checking of minimum interval }
  do i = nevents while i >= 2 by (-1)
    j = i - 1;
    t = adjubi( lcmc(j), ucmc(j), lcmc(i), ucmc(i), interv(i)+cdelay(i) );
    if t < 0 then
      if type(j) = 2 & type(i) <> 6 then
        if A722 = 95 & fsexflag = 0 then        { First sex when married }
          fsexflag = 5
        endif
      else
        x1 = type(j);
        x2 = type(i);
        recode x1 :: x2 -> eno;
                1 ::  2 -> 9901;    { Between birth and first union }
                1 ::  3 -> 9902;    { Between birth and first child }
                2 ::  3 -> 9903;    { Between union and first child }
              1,2 ::    -> 9904;    { Between birth or union and other events }
                3 ::  3 -> 9905;    { Between children }
                3 ::    -> 9906;    { Between last child and later events }
                  ::    -> 9907;    { Between other events }
        endrecode;
        if eno = 9905 then
          errmsg( eno, norder(i), i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                       cmc2m(ucmc(i)), cmc2y(ucmc(i)), norder(j), j, lcmc(j), ucmc(j),
                       cmc2m(lcmc(j)), cmc2y(lcmc(j)), cmc2m(ucmc(j)), cmc2y(ucmc(j)),
                       interv(i)+cdelay(i) );
        else
          errmsg( eno, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)),
                       cmc2y(ucmc(i)), j, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)),
                       cmc2m(ucmc(j)), cmc2y(ucmc(j)), interv(i)+cdelay(i) );
        endif;
        errflag(j) = default;
      endif;
    else
      ucmc(j) = t;
    endif;
  enddo;

{ --------------------------------------------------------------------------- }

  { forward checking of duration of use of contraceptive method }
  do k = nevents while type(k) > 4 by (-1) enddo;
  do i = chadj + 1 while i < k
    do j = i + 1 while twincode(j) <> default & twincode(j) > 1 enddo;
    t = adjlbi( lcmc(i), ucmc(i), lcmc(j), ucmc(j), durmeth(j)+interv(j) );
    if t < 0 then
      if errflag(i) <> default | errflag(j) <> default then
        if !ver100 then
          errmsg( 9917, j-chadj, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                        cmc2m(ucmc(i)), cmc2y(ucmc(i)), j, lcmc(j), ucmc(j), cmc2m(lcmc(j)),
                        cmc2y(lcmc(j)), cmc2m(ucmc(j)), cmc2y(ucmc(j)), durmeth(j), interv(j) );
        endif;
        kount(37) = kount(37) + 1;
        flagmeth(j) = 2;
        t = adjlbi( lcmc(i), ucmc(i), lcmc(j), ucmc(j), durmeth(j)+interv(j)-1 );
        if t < 0 then
          flagmeth(j) = 1
        endif
      endif
    else
      lcmc(j) = t;
    endif;
  enddo;

{ --------------------------------------------------------------------------- }

  { backward checking of duration of use of contraceptive method }
  do i = nevents while type(i) > 4 by (-1) enddo;
  do i = i while i >= chadj + 2 by (-1)  { This is using letter i = letter i as initialization for the loop as i already has the value }
    do k = i while twincode(k) <> default & twincode(k) > 1 enddo;
    j = i - 1;
    t = adjubi( lcmc(j), ucmc(j), lcmc(k), ucmc(k), durmeth(k)+interv(k) );
    if t < 0 then
      if (errflag(j) <> default | errflag(k) <> default) &
         (flagmeth(k) <> 1 & flagmeth(k) <> 2) then
        if !ver100 then
          errmsg( 9917, k-chadj, j, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)),
                        cmc2m(ucmc(j)), cmc2y(ucmc(j)), k, lcmc(k), ucmc(k), cmc2m(lcmc(k)),
                        cmc2y(lcmc(k)), cmc2m(ucmc(k)), cmc2y(ucmc(k)), durmeth(k), interv(k) );
        endif;
        kount(38) = kount(38) + 1;
        flagmeth(k) = 2;
        t = adjubi( lcmc(j), ucmc(j), lcmc(k), ucmc(k), durmeth(k)+interv(k)-1 );
        if t < 0 then
          flagmeth(k) = 1
        endif
      endif
    else
      ucmc(j) = t;
    endif;
  enddo;

{ --------------------------------------------------------------------------- }

  { checking time since last period with last pregnancy }
  recode A236U ::  A236N  -> lper;
              :: missing -> 0;
              ::  97-98  -> 0;
            9 ::     95  -> -1;
            9 ::     96  -> -2;
            9 ::     94  -> -3;
            1 ::         -> int(A236N/30);
            2 ::         -> int(A236N*WeeksMonth);
            3 ::         -> A236N;
            4 ::         -> A236N*12;
              ::         -> 0;
  endrecode;

  if lper >= 0 then             { last period reported }
    if Totpreg then
      i = Totpreg+chadj;
      t = adjubi( lcmc(i), ucmc(i), di, di, lper );
      if t < 0 then
        if lper <> 0 then
          if !ver100 then
            errmsg( 2364, Totpreg, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                          cmc2m(ucmc(i)), cmc2y(ucmc(i)), di, AINTM, AINTY, A236U, A236N )
          endif;
          kount(13) = kount(13) + 1;
          lperflag = 1;
          if AESEC4 & A476(1) = 2 then
            lperflag = 9
          endif
        endif
      else
        ucmc(i) = t;
        if A236U = 4 then
          t = adjubi( lcmc(i), ucmc(i), di, di, lper+11 );
        endif;
        if t > 0 & AESEC4 & A476(1) = 2 then
          if !ver100 then errmsg( 2365, A236U, A236N, A476(1) ) endif;
          kount(14) = kount(14) + 1;
          lperflag = 3
        else
          t = adjubi( lcmc(i), ucmc(i), di, di, lper );
          if t < 0 then
            if lper <> 0 then
              if !ver100 then
                errmsg( 2366, Totpreg, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                              cmc2m(ucmc(i)), cmc2y(ucmc(i)), di, AINTM, AINTY,
                              0, A236U, A236N )
              endif;
              kount(15) = kount(15) + 1;
              lperflag = 2
            endif
          else
            ucmc(i) = t;
          endif
        endif
      endif;
    endif;
    { Check period not during pregnancy }
    if currpreg & lper < currpregdur & A236N <> missing then
      if !ver100 then errmsg( 2370, A236U, A236N, A233N ) endif;
      if lperflag = 0 then
        lperflag = 7
      endif
    endif
{ --------------------------------------------------------------------------- }
  else                          { special responses to last period }
    if A236N = 96 then          { never menstruated }
      if A212W > 0 then         { but had a pregnancy }
        if !ver100 then errmsg( 2369, A236N, A212 ) endif;
        kount(18) = kount(18) + 1;
        lperflag = 8
      endif;
      x = 0;
      if AESEC4 & A476(1) <> 2 then          { Period returned after birth }
        if !ver100 then errmsg( 2367, A236N ) endif;
        kount(16) = kount(16) + 1;
        lperflag = 6
      endif;
    else
      if A236N = 95 & AESEC4 & A476(1) <> 2 then       { Before last birth }
        if !ver100 then errmsg( 2368, A236N, A476(1) ) endif;
        kount(17) = kount(17) + 1;
        lperflag = 5
      endif;
    endif;
  endif;

{ --------------------------------------------------------------------------- }

  { Sexual Intercourse }
  { checking of time since last sex with open interval }
  recode A723U ::  A723N  -> lsex;
               :: missing -> 0;
               ::  97-98  -> 0;
{            9 ::    96   -> -1;   { code no longer used } }
             0 ::         -> -1;
             1 ::         -> int(A723N/30);
             2 ::         -> int(A723N*WeeksMonth);
             3 ::         -> A723N;
             4 ::         -> A723N*12;
               ::         -> 0;
  endrecode;

  if lsex >= 0 then                     { last sex reported }
    if Totpreg then
      i = Totpreg+chadj;
      t = adjubi( lcmc(i), ucmc(i), di, di, lsex );
      if t < 0 then
        if lsex then
          if !ver100 then
            errmsg( 5153, Totpreg, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                          cmc2m(ucmc(i)), cmc2y(ucmc(i)), di, AINTM, AINTY, A723U, A723N )
          endif;
          kount(6) = kount(6) + 1;
          lsexflag = 1;
          if AESEC4 & A478(1) = 2 then
            lsexflag = 9
          endif
        endif
      else
        ucmc(i) = t;
        if A723U = 4 then
          t = adjubi( lcmc(i), ucmc(i), di, di, lsex+11 );
          if t < 0 & AESEC4 & A478(1) = 2 then
            lsexflag = 9
          endif;
        endif;
        if t > 0 & AESEC4 & A478(1) = 2 then
          if !ver100 then errmsg( 5154, A723U, A723N ) endif;
          kount(7) = kount(7) + 1;
          lsexflag = 3
        else
          t = adjubi( lcmc(i), ucmc(i), di, di, lsex );
          if t < 0 then
            if lsex then
              if !ver100 then
                errmsg( 5155, 0, A723U, A723N, Totpreg, i, lcmc(i), ucmc(i),
                              cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)),
                              cmc2y(ucmc(i)), di, AINTM, AINTY )
              endif;
              kount(8) = kount(8) + 1;
              lsexflag = 2
            endif
          else
            ucmc(i) = t;
          endif
        endif
      endif;
    endif;
    { Check last sex not longer ago than start of current pregnancy }
    if currpreg & lsex > currpregdur then
      if !ver100 then errmsg( 5157, A723U, A723N, A233N) endif;
      kount(10) = kount(10) + 1;
      if lsexflag = 0 | lsexflag = 8 then
        lsexflag = 7
      endif
    endif
{ --------------------------------------------------------------------------- }
  else                          { special responses to last sex }
  { This code is no longer needed, but is left here in case code of 96 is reinstated in a country }
    if A723N = 96 then          { last sex before last birth }
      if !A208 then             { never given birth }
        if !ver100 then errmsg( 5158, A723U, A723N, A208 ) endif;
        kount(11) = kount(11) + 1;
        lsexflag = 4;
      endif;
      if currpreg then          { currently pregnant, so since birth }
        if !ver100 then errmsg( 5152, A723U, A723N, A232 ) endif;
        kount(5) = kount(5) + 1;
        lsexflag = 5
      endif;
      if AESEC4 & A478(1) <> 2 then            { Sex resumed since last birth }
        if !ver100 then errmsg( 5156, A723U, A723N, A478(1) ) endif;
        kount(9) = kount(9) + 1;
        if lsexflag = 0 | lsexflag = 8 then
          lsexflag = 6
        endif
      endif
    endif
  endif;

  if A722 = 0 then            	{ Never had sexual intercourse }
    if A208 | A232 <> 2 then    { but has had children or is/possibly pregnant }
      errmsg( 5150, A722, A208, A232 );
    endif;
    if !A702 in 3,missing then        { Ever in union }
      if run1 then errmsg( 5151, A722, A701, A702 ) endif
    endif;
  endif;

{ -------------------------------------------------------------------------- }

  { Equalizing twins }
  umin = 9999;
  lmax = 0;
  ntwin = 0;
  do i = 1 while i <= Totpreg+chadj
    j = i + 1;
    if special(twincode(j)) | twincode(j) <= 1 then
      if umin < lmax then
        errmsg( 9920, j-1, lmax, umin, cmc2m(lmax), cmc2y(lmax), cmc2m(umin), cmc2y(umin) )
      else
        do k = 1 while k <= ntwin
          lcmc(j-k) = lmax;
          ucmc(j-k) = umin;
        enddo;
      endif;
      umin = 9999;
      lmax = 0;
      ntwin = 0;
    endif;
    if !special(twincode(j)) & twincode(j) >= 1 then
      ntwin = ntwin + 1;
      if lcmc(j) > lmax then lmax = lcmc(j) endif;
      if ucmc(j) < umin then umin = ucmc(j) endif;
    endif;
  enddo;

{ -------------------------------------------------------------------------- }

  { Preparation for imputation }
  if doimp then
    do i = 1 while i <= nevents-1
      if special(twincode(i)) | twincode(i) <= 1 then
        do j = nevents while j > i by (-1)
          if special(twincode(j)) | twincode(j) <= 1 then
            jinterv = 0;
            if j = i + 1 | (!special(twincode(j-1)) & i = j-twincode(j-1)) then
              jinterv = interv(j) + cdelay(j);
            endif;
            gap=ucmc(i)+jinterv-lcmc(j);
            if gap < 0 | lcmc(i) > lcmc(j) | ucmc(i) > ucmc(j) |
            (j = i+1 & errflag(i) = default & errflag(i+1) = default) then
              gap = 0
            endif;
            gap2 = int(gap/2);
            xgap = 0;
            if gap <> gap2*2 then xgap = 1 endif;
            ucmc(i) = ucmc(i) - gap2;
            lcmc(j) = lcmc(j) + gap2;
            if xgap = 1 then
              if ucmc(i) > lcmc(i) then
                ucmc(i) = ucmc(i) - 1
              else
                if ucmc(j) > lcmc(j) then
                  lcmc(j) = lcmc(j) + 1
                else
                  if !everUnion | i <> 2 | j <> 3 then
                    errmsg( 9918, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                                  cmc2m(ucmc(i)), cmc2y(ucmc(i)), j, lcmc(j), ucmc(j),
                                  cmc2m(lcmc(j)), cmc2y(lcmc(j)), cmc2m(ucmc(j)),
                                  cmc2y(ucmc(j)), jinterv );
                    errflag(i) = default
                  endif
                endif
              endif
            endif;
          endif;
        enddo;
      else
        lcmc(i) = lcmc(i-1);
        ucmc(i) = ucmc(i-1);
      endif;
    enddo;

{ -------------------------------------------------------------------------- }

  { Re-Adjust ranges for date of birth based on adjusted date/age at marriage }
    if everUnion & errflag(2) <> default & valid(A716) then
      t = ndjlba( lcmc(1), ucmc(1), lcmc(2), ucmc(2), A716 );
      if t < 0 then
        errmsg( 5134, A716, A715M, A715Y, AINTM, AINTY, A111, A110M, A110Y );
        errflag(2) = default;
      else
        lcmc(1) = t;
      endif;
      t = adjuba( lcmc(1), ucmc(1), lcmc(2), ucmc(2), A716 );
      if t < 0 then
        errmsg( 5134, A716, A715M, A715Y, AINTM, AINTY, A111, A110M, A110Y );
        errflag(2) = default;
      else
        ucmc(1) = t;
      endif
    endif;

{ -------------------------------------------------------------------------- }

    { Imputation - Random }

    { Impute date of birth of respondent }
    if lcmc(1) > ucmc(1) then
      errmsg( 9919, 1, lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)), cmc2m(ucmc(1)), cmc2y(ucmc(1)) );
      cmc(1) = default
    elseif lcmc(1) = ucmc(1) then
      cmc(1) = lcmc(1)
    else
      cmc(1) = random(lcmc(1),ucmc(1))
    endif;
    { Fix imputed date if a month given }
    if smonth(1) & (smonth(1) <> ((cmc(1) - 1) % 12) + 1) then
      x = int((cmc(1) - 1) / 12) * 12 + smonth(1);
      if x > ucmc(1) then x = x - 12 endif;
      if x < lcmc(1) then x = x + 12 endif;
      if x <= ucmc(1) then
        cmc(1) = x
      else
        errmsg( 9921, 1, smonth(1), lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)),
                      cmc2m(ucmc(1)), cmc2y(ucmc(1)), cmc(1), cmc2m(cmc(1)), cmc2y(cmc(1)) );
      endif;
    endif;

{ -------------------------------------------------------------------------- }

    { Re-adjust date of marriage based on       }
    { imputed date of birth and age at marriage }
    if valid(A716) then
      { Adjust functions used with dates upside down to allow   }
      { adjustment of date of marriage based on age at marriage }
      { rather than adjusting date of birth                     }
      t = adjuba( di-ucmc(2), di-lcmc(2), di-cmc(1), di-cmc(1), A716 );
      if t < 0 then
        if errflag(2) <> default then
          errmsg( 5133, A716, A715M, A715Y, A110M, A110Y, AINTM, AINTY, A111 );
          errflag(2) = default;
        endif
      else
        lcmc(2) = di-t;
      endif;
      t = ndjlba( di-ucmc(2), di-lcmc(2), di-cmc(1), di-cmc(1), A716 );
      if t < 0 then
        if errflag(2) <> default then
          errmsg( 5133, A716, A715M, A715Y, A110M, A110Y, AINTM, AINTY, A111 );
          errflag(2) = default
        endif
      else
        ucmc(2) = di-t
      endif;
    endif;

{ -------------------------------------------------------------------------- }

    { Imputation - Random }

    do i = 2 while i <= nevents
      if lcmc(i) > ucmc(i) then
        { Inconsistent date }
        cmc(i) = default;
        errmsg( 9919, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                      cmc2m(ucmc(i)), cmc2y(ucmc(i)) )
      elseif lcmc(i) = ucmc(i) then
        { Exact date }
        cmc(i) = lcmc(i)
      else
        { Imputed date }
        cmc(i) = random( lcmc(i), ucmc(i) );
        if i > chadj & i <= Totpreg+chadj & twincode(i) >= 1 then
          { Set same date for twins }
          do j = i+1 while j <= Totpreg+chadj & twincode(j) > twincode(i)
            lcmc(j) = cmc(i);
            ucmc(j) = cmc(i);
          enddo;
        endif;
      endif;

      { Fix imputed date if a month given }
      if smonth(i) & (smonth(i) <> ((cmc(i) - 1) % 12) + 1) then
        x = int((cmc(i) - 1) / 12) * 12 + smonth(i);
        if x > ucmc(i) then x = x - 12 endif;
        if x < lcmc(i) then x = x + 12 endif;
        if x <= ucmc(i) then
          cmc(i) = x
        else
          errmsg( 9921, i, smonth(i), lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                        cmc2m(ucmc(i)), cmc2y(ucmc(i)), cmc(i), cmc2m(cmc(i)), cmc2y(cmc(i)) );
        endif;
      endif;

{ -------------------------------------------------------------------------- }

      { Impute age at death if needed, otherwise update hot deck }
      if type(i) = 3 & A224(norder(i)) = 2 then

        { Hot Deck entries: }
        { LSTDU: Only elements 1-10 are used, representing birth orders 1-9,10+ }
        { LSTDN: Elements  1-10: duration in days   for birth orders 1-9,10+ }
        {        Elements 11-20: duration in months for birth orders 1-9,10+ }
        {        Elements 21-30: duration in years  for birth orders 1-9,10+ }

        j = i;
        if i > 10 then j = 10 endif;

        if A228U(norder(i)) = 9 | special(A228U(norder(i))) then
          du = lstdu(j);
          dn = lstdn(10*(du-1)+j);
          flagdth(i) = 8;
        else
          du = A228U(norder(i));
          if valid(A228N(norder(i))) then
            dn = A228N(norder(i));
          else
            dn = lstdn(10*(du-1)+j);
            flagdth(i) = 7
          endif;
          lstdu(j) = du;
          lstdn(10*(du-1)+j) = dn;
        endif;
        recode du -> dmonths;
                1 -> int(dn/30);
                2 -> dn;
                3 -> dn*12;
                  -> dn;
        endrecode;
        if dmonths < deathl(i) | dmonths > deathu(i) then
          if flagdth(i) = 7 | flagdth(i) = 8 |
             (du = 3 & dmonths < deathl(i) & dmonths+11 >= deathl(i)) then
            dmonths = deathl(i)
          endif
        endif;
        deathl(i) = dmonths;
        deathu(i) = dmonths;
      endif;

    enddo;

{ -------------------------------------------------------------------------- }

    A110C = cmc(1);                        { CMC date of birth }
    A110F = sflag(1);                      { Flag for date of birth }
    A111C = int( (di-A110C)/12 );          { Computed age of respondent }
    if everUnion then
      A715C = cmc(2);                      { CMC date of first union }
      A715F = sflag(2);                    { Flag for date of first union }
      A716C = int( (cmc(2)-cmc(1))/12 );   { Computed age at first union }
      if InUnion & A714 = 2 then
        A719C = random(lcmcm,ucmcm);       { CMC date of current union }
        A719F = cusflag;                   { Flag for date of current union }
        A720C = int((A719C-cmc(1))/12);    { Computed age at current union }
      endif;
    endif;
    do i = 1 while i <= Totpreg
      j = i + chadj;
      A220C(i) = cmc(j);                { CMC date of birth of child }
      xmonth = (A220C(i)-1) % 12 + 1;         { month of birth of child      }
      xyear  = int( (A220C(i)-1)/12 ) + 1900; { year  of birth of child      }
      xday   = A220D(i);
      if !A220D(i) in 1:31 then
        if i > 1 & A220C(i) = A220C(i-1) then      // check if twin pregnancy 
          xday = A220DI(i-1);    // copy date from prior twin 
        else 
          xday = ImputeDay( AINTY, AINTM, AINTD, xyear, xmonth );
        endif; 
      endif;
      A220DI(i) = xday;
      A220CD(i) = CDCode( xyear, xmonth, xday );
      A220F(i) = sflag(j);              { Flag for date of birth of child }
      if A224(i) = 2 then
        A228C(i) = deathl(j);           { Imputed age at death }
        A228F(i) = flagdth(j);          { Flag for age at death }
      endif;
    enddo;
    if type(nevents-1) = 4 then
      A233C = cmc(nevents-1);           { CMC date of conception of pregnancy }
      A233F = sflag(nevents-1);         { Flag for duration of pregnancy }
    endif;
    A236F = lperflag;                   { Flag for last period reporting }
    if type(nevents-1) = 5 then
      A314C = cmc(nevents-1);           { CMC date of sterilization }
      A314F = sflag(nevents-1);         { Flag for date of sterilization }
    endif;
    A722F = fsexflag;                   { Flag for first sex reporting }
    A723F = lsexflag;                   { Flag for last sex reporting }

  endif;      { end of imputation if no errors }

{ -------------------------------------------------------------------------- }

  { Check for errors and display event table }
  e = ( !doimp & !ver100 & (lsexflag | lperflag | fsexflag) );
  do i = 1 while i <= nevents
    ETsuppress = ( !run1 & type(i) = 5 );
    if !ETsuppress & ( errflag(i) = default |
       !doimp & !ver100 & (flagmeth(i) | flagdth(i)) ) then
      e = 1
    endif;
  enddo;

  if e then
    write( " " );
    write( "Cluster %04d   Household %04d     Woman's Line %02d", ACLUSTER, ANUMBER, ALINE );
    write( " " );
    write( "                         Minimum       Maximum         Con Meth   Age   ");
    write( "Ix  T Ord  M  S  F  E   Date    CMC   CMC   Date   Int cep Dur f death f");

    do i = 1 while i <= nevents
      if type(i) = 3 & surv(i) = 2 then
        xdeath = A228U(norder(i))*100;
        if A228N(norder(i)) = missing then
          xdeath = xdeath+99
        else
          xdeath = xdeath+A228N(norder(i))
        endif;
        sdeath = edit("ZZ999",xdeath);
      else
        xdeath = notappl;
        sdeath = "     ";
      endif;
      xdatemin = ((lcmc(i)-1)%12 + 1)*10000 + int((lcmc(i)-1)/12)+1900;
      xdatemax = ((ucmc(i)-1)%12 + 1)*10000 + int((ucmc(i)-1)/12)+1900;
      if errflag(i) = default then
        asterisk = "*"
      else
        asterisk = " ";
      endif;
      if type(i) = 3 then
        write( "%2d%3d%4d%3d%3d%3d%3s%8d%6d%6d%8d%5d%3d%5d%3d%5s%3d",
                i, type(i), norder(i),   twincode(i), surv(i),    sflag(i),
                asterisk,   xdatemin,    lcmc(i),     ucmc(i),    xdatemax,
                interv(i),  cdelay(i),   durmeth(i), flagmeth(i),
                sdeath,     flagdth(i) );
      elseif type(i) = 5 then
        write( "%2d%3d%7s%3d%3d%3s%8d%6d%6d%8d%5d",
                i, type(i), spaces,      surv(i),     sflag(i),    asterisk,    xdatemin,    lcmc(i),
                ucmc(i),    xdatemax,    interv(i) );
      else
        write( "%2d%3d%10s%3d%3s%8d%6d%6d%8d%5d",
                i, type(i), spaces,      sflag(i),    asterisk,    xdatemin,    lcmc(i),
                ucmc(i),    xdatemax,    interv(i) );
      endif;

    enddo;

    lper = A236U*100;                   { Last period }
    if A236N = missing then
      lper = lper+99
    else
      lper = lper+A236N
    endif;
    lsex = A723U*100;                   { Last sex }
    if A723N = missing then
      lsex = lsex+99
    else
      lsex = lsex+A723N
    endif;
    fsex = A722;                        { First sex }
    write( " " );
    write( "Last period %03d    Last sex %03d       Age at first sex  %02d",
           lper, lsex, fsex );
    write( "Flag        %3d             %3d                        %3d",
           lperflag, lsexflag, fsexflag );
  endif;

{ --------------------------------------------------------------------------- }
{ Maternal Mortality }
PROC AWSECM3_EDT
  swrt = 0;
  aold = 100;
  iold = 0;
  if AMM11 = 0 then
    aold = A111;
  endif;
  aoldest = aold;

  for i in $ do
    anew = aold;

    if AMM15 = 1 then           { sibling is still alive }
      if valid(AMM16) then      { sibling's age is valid }
        anew = AMM16;
      endif
    elseif AMM15 = 2 then       { sibling has died }
      if valid(AMM18) then      { age when they died }
        anew = AMM18;
        if valid(AMM17) then    { how many yrs ago did they die }
          anew = anew + AMM17
        endif;
      elseif valid(AMM17) then	{ # yrs ago when they died }
        anew = AMM17            { Age would be at least this, probably more }
      endif;
    endif;

    if anew > aold then
      errmsg( 9000, i, anew, iold, aold );
      swrt = 1;
    elseif valid(AMM16) | valid(AMM17) & valid(AMM18) then
      aold = anew;
      iold = i;
    endif;

    if AMM11 = i then            { Check respondent against siblings }
      if A111 > aold then
        errmsg( 9000, 0, A111, iold, aold );
        swrt = 1;
      else
        aold = A111;
        anew = A111;
        iold = 0;
      endif;
    endif;

    if aoldest = 100 then
      aoldest = aold;
    endif;

  enddo;

  if AMM07 > 0 and (aoldest - aold) > 30 then
    errmsg( 9001, aoldest, aold )
  endif;

  if swrt then
    write( "" );
    write( "    Maternal mortality      AMM07=%02d.  AMM11=%01d", AMM07, AMM11 );
    write( "" );
    write( "    AMM13 AMM14 AMM15 AMM16 AMM17 AMM18 AMM19 AMM20 AMM21 AMM22" );
    for j in $ do
      write("       %02d  %3d   %3d     %02d    %02d    %02d  %3d   %3d   %3d     %02d",
                  AMM13, AMM14, AMM15, AMM16, AMM17, AMM18, AMM19, AMM20, AMM21, AMM22 );
    enddo;
    write( "" );
  endif;

{ --------------------------------------------------------------------------- }
{ domestic violence }
PROC AWSECDV_EDT
  { check years in abusive relationship with marriage duration }
  if valid(DV18) & DV18 < 95 & DV18 > agew then
    if run1 then errmsg( 11001, DV18, agew ); endif;
  endif;

{ --------------------------------------------------------------------------- }
{ female genital cutting }
PROC AWSECG1_EDT
  { age at circumcision vs current age }
  if valid(GC07) & GC07 < 95 & GC07 > agew then
    errmsg( 11050, GC07, agew );
  endif;
  
{ --------------------------------------------------------------------------- }
{ men's questionnaire }
PROC AMSEC01_EDT
  { Initialize event table }
  do i = 1 while i <= maxevent
    norder(i)  = default;     { Birth order of children }
    surv(i)    = default;     { Survival status for children }
    deathl(i)  = default;     { Age at death of child - lower limit }
    deathu(i)  = default;     { Age at death of child - upper limit }
    sflag(i)   = default;     { Status code flag }
    errflag(i) = default;     { Error flag }
    durmeth(i) = default;     { Duration of method use before birth }
    flagmeth(i)= 0;           { Flag for method use before birth }
    flagdth(i) = 0;           { Flag for age at death of the child }
  enddo;
  lsexflag = 0;               { Flag for last sex }
  fsexflag = 0;               { Flag for age at first sex }
  inunion  = ( AM401 in 1,2 );

{ -------------------------------------------------------------------------- }

  { Date of birth of the man }

  { Check either year of birth or age given for all men }
  if !validyr(AM110Y) & !valid(AM111) then
    if run1 then errmsg( 21060, AM110M, AM110Y, AM111 ); endif;
  { Compare age of man with age in household to look for typos }
  elseif valid(AM111) & !( AM111 - AH07(ALINE) in (-2):2 ) then
    if run1 then errmsg( 21061, AM111, AH07(ALINE) ) endif;
  endif;

  { Set up event table entry for date of birth of man }
  nevents = 1;
  ismonth = valid(AM110M);
  isyear  = validyr(AM110Y);
  isage   = valid(AM111);
  if ismonth then
    smonth(1) = AM110M;
  else
    smonth(1) = 0;
  endif;
  recode isyear :: ismonth :: isage -> flag;
              1 ::       1 ::       -> 1;
                ::       1 ::     1 -> 2;
              1 ::         ::     1 -> 3;
              1 ::         ::       -> 5;
                ::         ::     1 -> 6;
                ::       1 ::       -> 7;
                ::         ::       -> 8;
  endrecode;
  if ignorey & flag = 3 & AM110Y + AM111 = AINTY then
    flag = 4
  endif;
  sflag(1)   = flag;
  errflag(1) = notappl;

  { Initial ranges for CMC date of birth }
  if validyr(AM110Y) & ( flag <> 4 | !doimp ) then
    lcmcb = setlb( AM110M, AM110Y, 0 );
    ucmcb = setub( AM110M, AM110Y, 9999 );
    if lcmcb < mindb then
      if ucmcb < mindb then
        errmsg( 21063, AM110M, AM110Y, AINTM, AINTY, cmc2m(mindb),
                       cmc2y(mindb), cmc2m(maxdb), cmc2y(maxdb) );
        errflag(1) = default;
        ucmcb = mindb;
      endif;
      lcmcb = mindb;
    endif;
    if ucmcb > maxdb then
      if lcmcb > maxdb then
        errmsg( 21063, AM110M, AM110Y, AINTM, AINTY,
                       cmc2m(mindb), cmc2y(mindb), cmc2m(maxdb), cmc2y(maxdb) );
        errflag(1) = default;
        lcmcb = maxdb;
      endif;
      ucmcb = maxdb;
    endif
  else
    lcmcb = mindb;
    ucmcb = maxdb;
  endif;

  type(1) = 1;
  interv(1) = 0;
  cdelay(1) = 0;

{ -------------------------------------------------------------------------- }

  { Adjust ranges for CMC date of birth based on age }
  if AM111 in minaim:maxaim then
    t = ndjlba( lcmcb, ucmcb, di, di, AM111 );
    if t < 0 then
      errmsg( 21062, AM110M, AM110Y, lcmcb, ucmcb, AM111, AINTM, AINTY, di );
      errflag(1) = default;
    else
      lcmcb = t;
    endif;
    t = adjuba( lcmcb, ucmcb, di, di, AM111 );
    if t < 0 then
      errmsg( 21062, AM110M, AM110Y, lcmcb, ucmcb, AM111, AINTM, AINTY, di );
      errflag(1) = default;
    else
      ucmcb = t;
    endif;
    x = di - (AM111*12 + 11);
    if lcmcb < x & x <= ucmcb then
      lcmcb = x
    endif
  endif;

{ -------------------------------------------------------------------------- }

  { For month only without year, make adjustment }
  if ismonth & !isyear then
    x = int( (lcmcb - 1)/12 ) * 12 + smonth(1);
    if x < lcmcb then
      x = x + 12
    endif;
    if x > ucmcb then
      if run1 then errmsg( 21064, smonth(1), lcmcb, ucmcb, cmc2m(lcmcb), cmc2y(lcmcb), cmc2m(ucmcb), cmc2y(ucmcb) ) endif;
    else
      lcmcb = x
    endif;
    x = int( (ucmcb - 1)/12 ) * 12 + smonth(1);
    if x > ucmcb then
      x = x - 12
    endif;
    if x < lcmcb then
      if run1 then errmsg( 21064, smonth(1), lcmcb, ucmcb, cmc2m(lcmcb), cmc2y(lcmcb), cmc2m(ucmcb), cmc2y(ucmcb) ) endif;
    else
      ucmcb = x
    endif;
  endif;

  { check Duration of current residence }
  if AM104 = 96 & AH05(ALINE) = 1 then
    errmsg( 21031, AM104, AH05(ALINE) )
  endif;
  agem = int( (di-lcmcb) / 12 );
  if AM104 in 0:49 & AM104 > agem then
    errmsg( 21030, AM104, AM110M, AM110Y, AM111 )
  endif;
  if validyr(AM106Y) & AM104 in 0:49 then
    temp = setub(AM106M, AM106Y, 9999);
	if int((di-temp)/12) > AM104 then
	  warning( 1035, AM106M, AM106Y, AM104 )
	endif;
  endif;

{ -------------------------------------------------------------------------- }

  { Date of marriage }
  everUnion = ( AM401 in 1,2 | AM402 in 1,2 );
  chadj = 1;                     { Adjustment for children in event table }
  if everUnion then              { added to line number of child          }
    chadj = 2;
    nevents = nevents + 1;
    ismonth = valid(AM411M);
    isyear  = validyr(AM411Y);
    isage   = valid(AM412);
    if ismonth then
      smonth(2) = AM411M;
    else
      smonth(2) = 0;
    endif;
    recode isyear :: ismonth :: isage -> flag;
             1    ::    1    ::       -> 1;
                  ::    1    ::   1   -> 2;
             1    ::         ::   1   -> 3;
             1    ::         ::       -> 5;
                  ::         ::   1   -> 6;
                  ::    1    ::       -> 7;
                  ::         ::       -> 8;
    endrecode;
    sflag(2)   = flag;
    errflag(2) = notappl;
    type(2)    = 2;
    { No year of marriage given, check if age given }
    if flag in 7,8 then
      if run1 then errmsg( 25135, AM412, AM411M, AM411Y ) endif;
    endif;

    { Initial ranges for date of marriage }
    if validyr(AM411Y) then
      lcmcm = setlb( AM411M, AM411Y, 0 );
      ucmcm = setub( AM411M, AM411Y,9999 );
      if ucmcm > di then ucmcm = di endif;
    else
      lcmcm = lcmcb + minamm;
      ucmcm = di;
    endif;

{ -------------------------------------------------------------------------- }

    { Adjust ranges for date of marriage based on age at marriage }
    if valid(AM412) then

      { Adjust functions used with dates upside down to allow   }
      { adjustment of date of marriage based on age at marriage }
      { rather than adjusting date of birth                     }
      t = adjuba( di-ucmcm, di-lcmcm, di-ucmcb, di-lcmcb, AM412 );
      if t < 0 then
        errmsg( 25132, AM412, AM411M, AM411Y, AINTM, AINTY, AM111, AM110M, AM110Y );
        errflag(2) = default;
      else
        lcmcm = di-t;
      endif;
      t = ndjlba( di-ucmcm, di-lcmcm, di-ucmcb, di-lcmcb, AM412 );
      if t < 0 then
        errmsg( 25132, AM412, AM411M, AM411Y, AINTM, AINTY, AM111, AM110M, AM110Y );
        errflag(2) = default;
      else
        ucmcm = di-t;
      endif;

{ -------------------------------------------------------------------------- }

    { Adjust ranges for date of birth based on age at marriage }
      if errflag(2) <> default then
        t = ndjlba( lcmcb, ucmcb, lcmcm, ucmcm, AM412 );
        if t < 0 then
          errmsg( 25131, AM412, AM411M, AM411Y, AM110M, AM110Y, AINTM, AINTY, AM111 );
          errflag(2) = default;
        else
          lcmcb = t;
        endif;
        t = adjuba( lcmcb, ucmcb, lcmcm, ucmcm, AM412 );
        if t < 0 then
          errmsg( 25131, AM412, AM411M, AM411Y, AM110M, AM110Y, AINTM, AINTY, AM111 );
          errflag(2) = default;
        else
          ucmcb = t;
        endif
      endif

    endif;

    { Check date of marriage not after date of interview }
    if lcmcm > di then
      errmsg( 25130, AM412, AM111, AINTM, AINTY, AM110M, AM110Y, AM411M, AM411Y );
      errflag(2) = default;
    elseif ucmcm > di then
      ucmcm = di
    endif;

{ -------------------------------------------------------------------------- }

    { For month only without year, make adjustment }
    if ismonth & !isyear then
      x = int( (lcmcm - 1)/12 ) * 12 + smonth(2);
      if x < lcmcm then
        x = x + 12
      endif;
      if x > ucmcm then
        errmsg( 25126, smonth(2), lcmcm, ucmcm, cmc2m(lcmcm), cmc2y(lcmcm), cmc2m(ucmcm), cmc2y(ucmcm) );
      else
        lcmcm = x
      endif;
      x = int( (ucmcm - 1)/12 ) * 12 + smonth(2);
      if x > ucmcm then
        x = x - 12
      endif;
      if x < lcmcm then
        errmsg( 25126, smonth(2), lcmcm, ucmcm, cmc2m(lcmcm), cmc2y(lcmcm), cmc2m(ucmcm), cmc2y(ucmcm) );
      else
        ucmcm = x
      endif;
    endif;

{ -------------------------------------------------------------------------- }

    { Adjust for minimum age at marriage }
    t = adjlbi( lcmcb, ucmcb, lcmcm, ucmcm, minamm );
    if t < 0 then
      if run1 then errmsg( 25121, int(minamm/12), AM110M, AM110Y, AM111, AM411M, AM411Y, AM412 ) endif;
      errflag(2) = default;
    else
      lcmcm = t;
    endif;

    { Check date of marriage not after date of interview }
    if lcmcm > di then
      errmsg( 25120, AM411M, AM411Y, AM412, AINTM, AINTY, AM110M, AM110Y, AM111 );
      errflag(2) = default;
    elseif ucmcm > di then
      ucmcm = di
    endif;

    { Use age at first sex as lower bound for date of marriage if no info. }
    if valid(AM414) & AM414 <> 0 & AM414 <= maxaim then
      t = adjlbi( lcmcb, ucmcb, lcmcm, ucmcm, AM414*12 );
      if t < 0 then
        if !ver100 then errmsg( 25193, AM411M, AM411Y, AM412, AM110M, AM110Y, AM414 ) endif;
        kount(46) = kount(46) + 1;
        fsexflag = 6;
      else
        lcmcm = t
      endif
    endif;

    lcmc(2) = lcmcm;
    ucmc(2) = ucmcm;
    interv(2) = minamm;
    cdelay(2) = 0;

  endif;

  lcmc(1) = lcmcb;
  ucmc(1) = ucmcb;

{ -------------------------------------------------------------------------- }

  { Time of interview }
  if AVISITS = 1 then
    if valid(AM101H) & valid(AM819H) then
      if AM101H > AM819H then
        errmsg( 28110, AM101H, AM101M, AM819H, AM819M );
      elseif AM101H = AM819H then
        if valid(AM101M) & valid(AM819M) & AM101M > AM819M then
          errmsg( 28110, AM101H, AM101M, AM819H, AM819M );
        endif
      endif
    endif
  endif;

  { Children ever born }
  Totpreg = AM208;
  minpd   = 7;     // minimum pregnacy duration for men

{ -------------------------------------------------------------------------- }

PROC AMSEC02_EDT

  { children }
  if Totpreg then                      { if at least one child }
    nevents    = nevents + 1;
    j          = nevents;
    type(j)    = 3;
    norder(j)  = 1;
    durmeth(j) = 0;
    flagmeth(j)= 0;

    { Initialize }
    lcmc(j) = lcmc(1) + minabm;
    ucmc(j) = di;
    sflag(j) = 8;
    errflag(j) = notappl;

{ -------------------------------------------------------------------------- }

    { Check age at first birth consistent with other information -- possibly including date of last birth }
    if valid(AM211) & AM211 <= maxaim then
      t = adjuba( di-ucmc(j), di-lcmc(j), di-ucmc(1), di-lcmc(1), AM211 );
      if t < 0 then
        if run1 then
          errmsg( 25180, AM211, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)), cmc2m(ucmc(j)),
                         cmc2y(ucmc(j)), lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)),
                         cmc2m(ucmc(1)), cmc2y(ucmc(1)), di, AINTM, AINTY )
        endif;
        errflag(j) = default;
      else
        lcmc(j) = di-t;
        t = ndjlba( di-ucmc(j), di-lcmc(j), di-ucmc(1), di-lcmc(1), AM211 );
        if t < 0 then
          if run1 then
            errmsg( 25180, AM211, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)), cmc2m(ucmc(j)),
                           cmc2y(ucmc(j)), lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)),
                           cmc2m(ucmc(1)), cmc2y(ucmc(1)), di, AINTM, AINTY )
          endif;
          errflag(j) = default;
        else
          ucmc(j) = di-t;
        endif;
      endif;
    endif;

    { Check first birth not before age at first sex }
    if valid(AM414) & AM414 <> 0 & AM414 <= maxaim then
      t = adjlbi( lcmc(1), ucmc(1), lcmc(j), ucmc(j), AM414*12+minpd );
      if t < 0 then
        if !ver100 then errmsg( 25191, AM414, AM211, AM110M, AM110Y ) endif;
        kount(44) = kount(44) + 1;
        fsexflag = 3;
        t = adjlbi( lcmc(1), ucmc(1), lcmc(j), ucmc(j), (AM414-1)*12+minpd );
        if t < 0 then
          fsexflag = 2
        endif
      else
        lcmc(j) = t;
      endif
    { Check minimum birth interval after marriage }
    elseif AM414 = 95 & everUnion then                                  { !!! first sex when married }
      t = adjlbi( lcmc(2), ucmc(2), lcmc(j), ucmc(j), minpd );
      if t < 0 then
        if !ver100 then errmsg( 25194, AM414, AM211, AM411M, AM411Y, AM412 ) endif;
        kount(47) = kount(47) + 1;
        fsexflag = 5;
      else
        lcmc(j) = t;
      endif
    endif;
  endif;        { end Totpreg }

  { Check age of youngest child consistent with father's age }
  if valid(AM213) & AM213+int(minabm/12) > agem then
    if !ver100 then errmsg( 22140, AM213, agem, int(minabm/12) ) endif;
  endif;

  { Date of conception of current pregnancy }
  currpreg = ( AM504 = 1 | AM509 = 1 );
  if currpreg then
    nevents = nevents + 1;
    errflag(nevents) = notappl;
    smonth(nevents) = 0;
    sflag(nevents) = 8;
    lcmc (nevents) = di - 9;
    ucmc (nevents) = di;
    norder(nevents) = Totpreg+1;
    type  (nevents) = 4;
    interv(nevents) = 0;
    if Totpreg then
      cdelay(nevents) = mincd   { minimum conception delay after last birth }
    else
      cdelay(nevents) = 0
    endif;
    durmeth(nevents) = 0;
  endif;

{ --------------------------------------------------------------------------- }
{ marriage and sexual activity }
PROC AMSEC04_EDT

  { check number of wives }
  if inunion & AM405 = 2 then
    nwives = 1
  else
    nwives = NAtoZero(AM406);
  endif;
  if nwives <> count(AMSEC04_GRP000) then
    errmsg( 25050, nwives, count(AMSEC04_GRP000) );
  endif;

  rh = AH03(ALINE);
  for i in AMSEC04_GRP000 do

    { Checking line number of wife/partner }
    { Store respondent's line & marital status to check at level 1 postproc }
    do j = 1 while j <= maxelig &
      ( manwife(j,1) <> 0 &
      ( manwife(j,1) <> ALINE | (manwife(j,3) <> 0 & manwife(j,3) <> AM407) ) )
    enddo;
    manwife(j,1) = ALINE;
    manwife(j,2) = AM401;
    manwife(j,3) = NAtoZero(AM407);

    trymatch = inunion;
    { Check if line number is out of range }
    if !special(AM407) & AM407 <> 0 then
      trymatch = 0;
      if AM407 > AHMEMBER then
        errmsg( 25060, AM407, i, AHMEMBER );
        trymatch = 1;
      else
        { Check partner is female }
        if AH04(AM407) <> 2 then
          errmsg( 25061, AH04(AM407), i, AM407 );
          trymatch = 1;
        endif;
        { Check partner is at least age 12 }
        if !special(AH07(AM407)) & AH07(AM407) < 12 then
          errmsg( 25062, AH07(AM407), i, AM407 );
          trymatch = 1;
        endif;
        { Check relationship of respondent to partner }
        rw = AH03(AM407);
        recode rh :: rw -> err;       { HUSBAND             - WIFE           }
                1 ::  2 -> 0;         { Head                - Spouse         }
                2 ::  1 -> 0;         { Spouse              - Head           }
                3 ::  4 -> 0;         { Son/daughter        - Son/Daughter-in-law}
                4 ::  3 -> 0;         { Son/Daughter-in-law - Son/Daughter   }
                4 :: 10 -> 0;         { Son/Daughter-in-law - Step-Daughter  }
                5 ::  9 -> 0;         { Grandchild          - Other Relative }
                6 ::  6 -> 0;         { Father              - Mother         }
                7 ::  7 -> 0;         { Father-in-law       - Mother-in-law  }
                8 ::  9 -> 0;         { Brother             - Other Relative }
                9 ::  5 -> 0;         { Other Relative      - Grandchild     }
                9 ::  8 -> 0;         { Other Relative      - Sister         }
                9 :: 11 -> 0;         { Other Relative      - Other Relative }
               10 ::  4 -> 0;         { Adopted             - Daughter-in-law}
            10,11 :: 11 -> 0;         { Adopted/Not Related - Not Related    }
		       11 :: 10 -> 0;         { Not related         - Adopted        }
       missing,98 :: 98,missing -> 0; { Unknown             - Unknown        }
                  ::    -> 1;         { All others are incorrect             }
        endrecode;
        if err then
          if run1 then errmsg( 25064, i, AM407, rh, rw ) endif;
          trymatch = 1;
        endif;
        { Check wife's age with age declared in the household }
        if valid(AH07(AM407)) & AM408 <> AH07(AM407) then
          if run1 then errmsg( 25068, AM407, AM408, AH07(AM407) ) endif;
        endif;
      endif;
    endif;
  enddo;

  { Head/Spouse/Son/Son-in-law/Father/Father-in-law -- try and find wife }
  if trymatch & rh in 1:4,6:7 then
    for j in record AHSEC01 do
      rw = AH03;
      recode rh :: rw -> rok;
              1 :: 2  -> 1;   { Head          - Spouse          }
              2 :: 1  -> 1;   { Spouse        - Head            }
              3 :: 4  -> 1;   { Son           - Daughter-in-law }
              4 :: 3  -> 1;   { Son-in-law    - Daughter        }
              6 :: 6  -> 1;   { Father        - Mother          }
              7 :: 7  -> 1;   { Father-in-law - Mother-in-law   }
                ::    -> 0;
      endrecode;
      { Found probable wife for man }
      { if female, relationship OK }
      if AH04 = 2 & rok &
         { not son or son-in-law }
        ((rh <> 3 & rh <> 4) |
         { only son with daughter-in-law anywhere in list }
         (rh = 3 & (count( ccHH80.AHSEC01 where AH03 = 4 & AH06 = 2) = 1 |
                   { son with daughter-in-law immediately after }
                   j = ALINE+1)
         ) |
         { son-in-law with only one daughter anywhere in list }
         (rh = 4 & (count( ccHH80.AHSEC01 where AH03 = 3 & AH06 = 2) = 1 |
                   { son-in-law with daughter immediately before or after }
                   j = ALINE-1 | j = ALINE+1)
         )
        ) then
        { See if wife listed in husband's questionnaire }
        if !count(AMSEC04_GRP000 where AM407 = j) then
          errmsg( 25063, j, rw, ALINE, rh )
        endif;
      endif;
    enddo;
  endif;

  { Check age at first sex }
  if AM414 <> missing & AM414 <> 0 & AM414 <= maxaim then
    if AM414 > agem then                { Exceeds current age }
      if run1 then errmsg( 25190, AM414, AM111, AINTM, AINTY, AM110M, AM110Y ) endif;
      fsexflag = 1;
    endif
  elseif AM414 = 95 & !everUnion then             { First time when married }
    if !ver100 then errmsg( 25192, AM414, AM402 ) endif;     { but never married }
    kount(45) = kount(45) + 1;
    fsexflag = 4;
  endif;

  { no sex in the last year but wife pregnant/DK }
  if AM415U = 4 & ( AM504 in 1,8 | AM509 in 1,8 ) then
    errmsg( 25200, AM415U, AM415N, AM504, AM509 )
  endif;

  { Check current methods are known }
  do x = 1 while x <= length( strip(AM418) )
    xmeth = pos( AM418[x:1], curmethm );
    if AM301(xmeth) <> 1 then                     { methods should be known }
      errmsg( 23142, GetLabel(AM418, AM418[x:1]) );
    endif;
  enddo;

  { # of lifetime partners should be equal or higher than # of partners in last 12 months }  { added October 14, 2011 from data entry - Claudia }
  sexp = (AM414 <> 0) + (AM423 = 1) + (AM426 = 1);
  if valid(AM429) & AM429 < sexp then
    errmsg( 25245, sexp )
  endif;

  { condom use and knowledge in contraceptive table }
  if (AM419 = 1 | AM424 = 1 | AM427 = 1) & AM301(condom) <> 1 then
    errmsg( 26280, AM419, AM424, AM427, AM301(condom) );
  endif;

{ --------------------------------------------------------------------------- }
{ fertility preferences }
PROC AMSEC05_EDT

  { check ideal number of children }
  if valid(AM515A) & valid(AM515B) & valid(AM515C) & AM515C < 96 &
         AM515A+AM515B+AM515C <> AM514 then
    errmsg(26131,AM515A,AM515B,AM515C,AM514);
  endif;


{ --------------------------------------------------------------------------- }
{ employment and gender roles, serve mainly as an anchor for imputation       }
PROC AMSEC06_EDT
  { decision on respondent's earnings }
  if AM609 in 2,3 & !inunion then
    errmsg( 27250, "AM609", AM609, AM401 )
  endif;
  { decision on respondent's health care }
  if AM610 in 2,3 & !inunion then
    errmsg( 27250, "AM610", AM610, AM401 )
  endif;
  { decision on making major purchases }
  if AM611 in 2,3 & !inunion then
    errmsg( 27250, "AM611", AM611, AM401 )
  endif;
  { ownership of a house }
  if AM612 in 2,4 & !inunion then
    errmsg( 27250, "AM612", AM612, AM401 )
  endif;
  { ownership of land }
  if AM615 in 2,4 & !inunion then
    errmsg( 27250, "AM615", AM615, AM401 )
  endif;

  { Date of interview event and open birth interval }
  nevents = nevents + 1;
  lcmc(nevents)   = di;
  ucmc(nevents)   = di;
  type(nevents)   = 6;
  sflag(nevents)  = 1;
  smonth(nevents) = 0;
  errflag(nevents)= notappl;
  interv(nevents) = 0;
  cdelay(nevents) = 0;
  durmeth(nevents) = 0;

{ -------------------------------------------------------------------------- }

  if Totpreg then
    { forward checking of date of first birth }
    i = chadj + 1;
    t = adjlbi( lcmc(1), ucmc(1), lcmc(i), ucmc(i), minabm );
    if t < 0 then
      errmsg( 29902, 1, lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)), cmc2m(ucmc(1)),
                     cmc2y(ucmc(1)), i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                     cmc2m(ucmc(i)), cmc2y(ucmc(i)), minabm );
      errflag(i) = default;
    else
      lcmc(i) = t;
      { backward checking of date of first birth }
      t = adjubi( lcmc(1), ucmc(1), lcmc(i), ucmc(i), minabm );
      if t < 0 then
        errmsg( 29902, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)),
                       cmc2y(ucmc(i)), 1, lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)),
                       cmc2m(ucmc(1)), cmc2y(ucmc(1)), minabm );
        errflag(1) = default;
      else
        ucmc(1) = t;
      endif;
    endif;
  endif;

{ -------------------------------------------------------------------------- }

  { forward checking of minimum interval }
  do i = 1 while i <= nevents - 1
    j = i + 1;
    t = adjlbi( lcmc(i), ucmc(i), lcmc(j), ucmc(j), interv(j)+cdelay(j) );
    if t < 0 then
      if type(i) = 2 & type(j) <> 6 then
        if AM414 = 95 & fsexflag = 0 then
          fsexflag = 5
        endif
      else
        x1 = type(i);
        x2 = type(j);
        recode x1 :: x2 -> eno;
                1 ::  2 -> 29901;    { Between birth and first union }
                1 ::  3 -> 29902;    { Between birth and first child }
                2 ::  3 -> 29903;    { Between union and first child }
              1,2 ::    -> 29904;    { Between birth or union and other events }
                3 ::  3 -> 29905;    { Between children }
                3 ::    -> 29906;    { Between last child and later events }
                  ::    -> 29907;    { Between other events }
        endrecode;
        if eno = 29905 then
          errmsg( eno, norder(i), i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)),
                       cmc2y(ucmc(i)), norder(j), j, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)),
                       cmc2m(ucmc(j)), cmc2y(ucmc(j)), interv(j)+cdelay(j) );
        else
          errmsg( eno, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)), cmc2y(ucmc(i)),
                       j, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)), cmc2m(ucmc(j)), cmc2y(ucmc(j)),
                       interv(j)+cdelay(j) );
        endif;
        errflag(j) = default;
      endif;
    else
      lcmc(j) = t;
    endif;
  enddo;

{ -------------------------------------------------------------------------- }

  { backward checking of minimum interval }
  do i = nevents while i >= 2 by (-1)
    j = i - 1;
    t = adjubi( lcmc(j), ucmc(j), lcmc(i), ucmc(i), interv(i)+cdelay(i) );
    if t < 0 then
      if type(j) = 2 & type(i) <> 6 then
        if AM414 = 95 & fsexflag = 0 then        { First sex when married }
          fsexflag = 5
        endif
      else
        x1 = type(j);
        x2 = type(i);
        recode x1 :: x2 -> eno;
                1 ::  2 -> 29901;    { Between birth and first union }
                1 ::  3 -> 29902;    { Between birth and first child }
                2 ::  3 -> 29903;    { Between union and first child }
              1,2 ::    -> 29904;    { Between birth or union and other events }
                3 ::  3 -> 29905;    { Between children }
                3 ::    -> 29906;    { Between last child and later events }
                  ::    -> 29907;    { Between other events }
        endrecode;
        if eno = 29905 then
          errmsg( eno, norder(i), i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)),
                       cmc2y(ucmc(i)), norder(j), j, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)),
                       cmc2m(ucmc(j)), cmc2y(ucmc(j)), interv(i)+cdelay(i) );
        else
          errmsg( eno, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)), cmc2y(ucmc(i)),
                       j, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)), cmc2m(ucmc(j)), cmc2y(ucmc(j)),
                       interv(i)+cdelay(i) );
        endif;
        errflag(j) = default;
      endif;
    else
      ucmc(j) = t;
    endif;
  enddo;

{ -------------------------------------------------------------------------- }

  { Sexual Intercourse }
  { checking of time since last sex with open interval }
  recode AM415U :: AM415N  -> lsex;
                :: missing -> 0;
                ::  97:98  -> 0;
{             9 ::     96  -> -1;}{Not used}
              0 ::         -> -1;
              1 ::         -> int(AM415N/30);
              2 ::         -> int(AM415N*WeeksMonth);
              3 ::         -> AM415N;
              4 ::         -> AM415N*12;
                ::         -> 0;
  endrecode;

  if lsex >= 0 then                     { last sex reported }
    if Totpreg then
      i = Totpreg+chadj;
      t = adjubi( lcmc(i), ucmc(i), di, di, lsex );
      if t < 0 then
        if lsex then
          if !ver100 then
            errmsg( 25153, Totpreg, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)),
                           cmc2y(ucmc(i)), di, AINTM, AINTY, AM415U, AM415N )
          endif;
          kount(48) = kount(48) + 1;
          lsexflag = 1;
        endif
      else
        ucmc(i) = t;
        if AM415U = 4 then
          t = adjubi( lcmc(i), ucmc(i), di, di, lsex+11 );
        endif;
      endif;
    endif;
{ -------------------------------------------------------------------------- }
  else                          { special responses to last sex }
    { This code is no longer needed, but is left here in case the code is used in a country }
    if AM415N = 96 then         { last sex before last birth }
      if !AM208 then            { never given birth }
        if !ver100 then errmsg( 25158, AM415U, AM415N, AM208 ) endif;
        kount(49) = kount(49) + 1;
        lsexflag = 4
      endif;
    endif
  endif;

  if AM414 = 0 then     { Never had sexual intercourse }
    if AM208 | AM504 in 1,8 | AM509 in 1,8 then   { but had children, or a partner is or maybe pregnant }
      errmsg( 25150, AM414, AM208, AM504, AM509 );
    endif;
    if !AM402 in 3,missing then        { Ever in union }
      if run1 then errmsg( 25151, AM414, AM401, AM402 ) endif;
    endif;
  endif;

{ -------------------------------------------------------------------------- }

  { Preparation for imputation }
  if doimp then
    do i = 1 while i <= nevents-1
      do j = nevents while j > i by (-1)
        jinterv = 0;
        if j = i + 1 then
          jinterv = interv(j) + cdelay(j);
        endif;
        gap=ucmc(i)+jinterv-lcmc(j);
        if gap < 0 | lcmc(i) > lcmc(j) | ucmc(i) > ucmc(j) |
        (j = i+1 & errflag(i) = default & errflag(i+1) = default) then
          gap = 0
        endif;
        gap2 = int(gap/2);
        xgap = 0;
        if gap <> gap2*2 then xgap = 1 endif;
        ucmc(i) = ucmc(i) - gap2;
        lcmc(j) = lcmc(j) + gap2;
        if xgap = 1 then
          if ucmc(i) > lcmc(i) then
            ucmc(i) = ucmc(i) - 1
          else
            if ucmc(j) > lcmc(j) then
              lcmc(j) = lcmc(j) + 1
            else
              if !everUnion | i <> 2 | j <> 3 then
                errmsg( 29918, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)),
                               cmc2y(ucmc(i)), j, lcmc(j), ucmc(j), cmc2m(lcmc(j)), cmc2y(lcmc(j)),
                               cmc2m(ucmc(j)),cmc2y(ucmc(j)), jinterv );
                errflag(i) = default
              endif
            endif
          endif
        endif;
      enddo;
    enddo;

{ -------------------------------------------------------------------------- }

  { Re-Adjust ranges for date of birth based on adjusted date/age at marriage }
    if everUnion & errflag(2) <> default & valid(AM412) then
      t = ndjlba( lcmc(1), ucmc(1), lcmc(2), ucmc(2), AM412 );
      if t < 0 then
        errmsg( 25134, AM412, AM411M, AM411Y, AINTM, AINTY, AM111, AM110M, AM110Y );
        errflag(2) = default;
      else
        lcmc(1) = t;
      endif;
      t = adjuba( lcmc(1), ucmc(1), lcmc(2), ucmc(2), AM412 );
      if t < 0 then
        errmsg( 25134, AM412, AM411M, AM411Y, AINTM, AINTY, AM111, AM110M, AM110Y );
        errflag(2) = default;
      else
        ucmc(1) = t;
      endif
    endif;

{ -------------------------------------------------------------------------- }

    { Imputation - Random }

    { Impute date of birth of respondent }
    if lcmc(1) > ucmc(1) then
      errmsg( 29919, 1, lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)), cmc2m(ucmc(1)), cmc2y(ucmc(1)) );
      cmc(1) = default
    elseif lcmc(1) = ucmc(1) then
      cmc(1) = lcmc(1)
    else
      cmc(1) = random(lcmc(1),ucmc(1))
    endif;
    { Fix imputed date if a month given }
    if smonth(1) & (smonth(1) <> ((cmc(1) - 1) % 12) + 1) then
      x = int( (cmc(1) - 1) / 12 ) * 12 + smonth(1);
      if x > ucmc(1) then x = x - 12 endif;
      if x < lcmc(1) then x = x + 12 endif;
      if x <= ucmc(1) then
        cmc(1) = x
      else
        errmsg( 29921, 1, smonth(1), lcmc(1), ucmc(1), cmc2m(lcmc(1)), cmc2y(lcmc(1)), cmc2m(ucmc(1)),
                       cmc2y(ucmc(1)), cmc(1), cmc2m(cmc(1)), cmc2y(cmc(1)) );
      endif;
    endif;

{ -------------------------------------------------------------------------- }

    { Re-adjust date of marriage based on       }
    { imputed date of birth and age at marriage }
    if valid(AM412) then
      { Adjust functions used with dates upside down to allow   }
      { adjustment of date of marriage based on age at marriage }
      { rather than adjusting date of birth                     }
      t = adjuba( di-ucmc(2), di-lcmc(2), di-cmc(1), di-cmc(1), AM412 );
      if t < 0 then
        if errflag(2) <> default then
          errmsg( 25133, AM412, AM411M, AM411Y, AM110M, AM110Y, AINTM, AINTY, AM111 );
          errflag(2) = default;
        endif
      else
        lcmc(2) = di-t;
      endif;
      t = ndjlba( di-ucmc(2), di-lcmc(2), di-cmc(1), di-cmc(1), AM412 );
      if t < 0 then
        if errflag(2) <> default then
          errmsg( 25133, AM412, AM411M, AM411Y, AM110M, AM110Y, AINTM, AINTY, AM111 );
          errflag(2) = default
        endif
      else
        ucmc(2) = di-t
      endif;
    endif;

{ -------------------------------------------------------------------------- }

    { Imputation - Random }

    do i = 2 while i <= nevents
      if lcmc(i) > ucmc(i) then
        { Inconsistent date }
        cmc(i) = default;
        errmsg( 29919, i, lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)), cmc2m(ucmc(i)), cmc2y(ucmc(i)) );
      elseif lcmc(i) = ucmc(i) then
        { Exact date }
        cmc(i) = lcmc(i)
      else
        { Imputed date }
        cmc(i) = random(lcmc(i),ucmc(i));
      endif;

      { Fix imputed date if a month given }
      if smonth(i) & (smonth(i) <> ((cmc(i) - 1) % 12) + 1) then
        x = int( (cmc(i) - 1) / 12 ) * 12 + smonth(i);
        if x > ucmc(i) then x = x - 12 endif;
        if x < lcmc(i) then x = x + 12 endif;
        if x <= ucmc(i) then
          cmc(i) = x
        else
          errmsg( 29921, i, smonth(i), lcmc(i), ucmc(i), cmc2m(lcmc(i)), cmc2y(lcmc(i)),
                         cmc2m(ucmc(i)), cmc2y(ucmc(i)), cmc(i), cmc2m(cmc(i)), cmc2y(cmc(i)) );
        endif;
      endif;
    enddo;

{ -------------------------------------------------------------------------- }

    AM110C = cmc(1);                    { CMC date of birth }
    AM110F = sflag(1);                  { Flag for date of birth }
    AM111C = int((di-AM110C)/12);       { Computed age of respondent }
    if everUnion then
      AM411C = cmc(2);                  { CMC date of first union }
      AM411F = sflag(2);                { Flag for date of first union }
      AM412C = int((cmc(2)-cmc(1))/12); { Computed age at first union }
    endif;
    x = Totpreg; if x > 2 then x = 2 endif;
    do i = 1 while i <= x
      j = i + chadj;
    { **** Use these if first birth date collected
      if i = 1 then
        AM211C = cmc(j);                { CMC date of birth of first child }
        AM211F = sflag(j);              { Flag for date of birth of first child }
      endif;
     **** }
    enddo;
    AM414F = fsexflag;                   { Flag for first sex reporting }
    AM415F = lsexflag;                   { Flag for last sex reporting }

  endif;      { end of imputation if no errors }

{ -------------------------------------------------------------------------- }

  { Check for errors and display event table }
  e = 0; { was (!doimp & run1); }
  do i = 1 while i <= nevents
    if errflag(i) = default |
       !doimp & (flagmeth(i) | flagdth(i)) then
      e = 1
    endif;
  enddo;
  if e then
    write( " " );
    write( "Cluster %04d     Household %04d     Man's Line %02d", ACLUSTER, ANUMBER, ALINE );
    write( " " );
    write( "                         Minimum       Maximum         Con Meth   Age   ");
    write( "Ix  T Ord  M  S  F  E   Date    CMC   CMC   Date   Int cep Dur f death f");
    do i = 1 while i <= nevents
      xdatemin = ( (lcmc(i)-1)%12 + 1 )*10000 + int( (lcmc(i)-1)/12 )+1900;
      xdatemax = ( (ucmc(i)-1)%12 + 1 )*10000 + int( (ucmc(i)-1)/12 )+1900;
      if errflag(i) = default then
        asterisk = "*"
      else
        asterisk = " ";
      endif;
      if type(i) = 3 then
        write( "%2d%3d%4d%3d%3d%3d%3s%8d%6d%6d%8d%5d%3d%5d%3d%5s%3d",
                i, type(i), norder(i),   twincode(i), surv(i),    sflag(i),
                asterisk,   xdatemin,    lcmc(i),     ucmc(i),    xdatemax,
                interv(i),  cdelay(i),   durmeth(i), flagmeth(i),
                sdeath,     flagdth(i) );
      elseif type(i) = 5 then
        write( "%2d%3d%7s%3d%3d%3s%8d%6d%6d%8d%5d",
                i, type(i), spaces,      surv(i),     sflag(i),    asterisk,    xdatemin,    lcmc(i),
                ucmc(i),    xdatemax,    interv(i) );
      else
        write( "%2d%3d%10s%3d%3s%8d%6d%6d%8d%5d",
                i, type(i), spaces,      sflag(i),    asterisk,    xdatemin,    lcmc(i),
                ucmc(i),    xdatemax,    interv(i) );
      endif;
    enddo;
    lsex = AM415U*100;                  { Last sex }
    if AM415N = missing then
      lsex = lsex+99
    else
      lsex = lsex+AM415N
    endif;
    fsex = AM414;                       { First sex }
    write( " " );
    write( "                   Last sex %03d       Age at first sex  %02d",
           lsex, fsex );
    write( "                            %3d                        %3d",
           lsexflag, fsexflag );
  endif;

