{Application 'CentralMenu' logic file generated by CSPro }
PROC GLOBAL

  FILE      piffile;                    { data entry PFF file for the Application }
  FILE      fromckid;                   { to read file generated by PECkid        }

  string TheCommand;
  string cmdline;                       { Used as a command line or to read strings }
  string CSPro;                         { CSPro executables directory }
  string AppName;                       { AppNamelication name }
  string opid;                          { operator ID }
  string wrkprj, wrkpii, superv, backup;  { directories }
  string wrkref;                        { contains refernce data for clusters, sample, teams }
  string arrived, closed, reports, work, utility;
  string entry, central, temp;
  string xparaux, zsupname;
  string chkfile;
  string fname;                         { filenames for various files }
  string xparamet;                      {   1-2 Interviewer,           3-4 supervisor,
                                              5 modify central office    6 revisitar hogar
                                              7 modificar hogar          8 caso salvado parcialmente
                                              9 entrar peso y talla
                                          10-11 Dwelling number      12-13 Household number
                                          14-15 Respondent line number }
  alpha(4) xsupnum;                     { Supervisor }
  alpha(4) xcluster;                    { Cluster number }
  string heading;
  string sname;						    { Supervisor's name }
  string dirbkp;

  array intvwcode(300);                 { to store interviewers }
  array intvwrole(300);
  array intvwteam(300);
  array intvwsex(300);
  array string intvwname(300);
  valueset fieldworkers;

  list string NewClusters;

  array string executable(3) = "Batch", "Entry", "Sort";
  
  numeric steam;
  numeric exist, action, filerep, x, i, j, y, totintvw, test;

  { setup basic user bar }
  function userbase();
    userbar( clear );
    userbar( add button, "Lang", do("ChangeLanguage") );
  end;

  { set value sets based on language }
  function OnChangeLanguage()
    SetLanguage( getlanguage() );
    savesetting("Language", getlanguage());
  end;

  { runs an Application from a given directory }
  function runpff()
    ExecPff( AppName + ".pff", maximized, wait );
  end;

  { Views a text file }
  function textview( string directory, string fileview );
    { Using single quotes instead of double quotes as double quotes are needed in the string generated }
    TheCommand = '"' + cspro + '\TextView.exe" "' + directory + '\' + fileview + '"';
    ExecSystem( TheCommand, maximized, wait );
  end;
  
  { checks if a cluster has already been closed or not }
  function clustopen()
    open( CONTROL );
    x = 1;
    CSAMPLE = WCLUSTER;
    if !loadcase( CONTROL, CSAMPLE ) then
      x = 0;
      errmsg( 007, CSAMPLE );
    elseif CACCEPT then
      errmsg( tr("Cluster %d already accepted"), CSAMPLE );
      x = accept( tr("Accept Cluster again"), tr("Yes"), tr("No") );
      if x = 2 then x = 0 endif;
    endif;
    close( CONTROL );
    clustopen = x;
  end;

  { checks a cluster status before a modification to know if: }
  { 1-cluster was already closed                              }
  { 2-cluster already passed secondary editing                }
  { 3-cluster was already accepted                            }
  function valstatus( xtype )
  { xtype 1 - Modify for structural problems }
  {       2 - Modify for secondary editing   }
  {       3 - Close cluster                  }
    open( CONTROL );
    x = 0;
    CSAMPLE = WCLUSTER;
    if !loadcase( CONTROL, CSAMPLE ) then
      x = errmsg( 007, CSAMPLE );
    { for either structure/secondary-editing/close but cluster already closed }
    elseif CFINDATE then
      x = errmsg( 008, CSAMPLE );
    { modify for structure but cluster already passed secondary editing }
    elseif xtype = 1 & CEDIT(1) then
      x = errmsg( 009, CSAMPLE );
    { modify for structure but cluster already accepted }
    elseif xtype = 1 & CACCEPT then
      x = errmsg( 013, CSAMPLE );
    { browse data but cluster haven't been accepted yet }
    elseif xtype in 2:3 & !CACCEPT then
      x = errmsg( 018, CSAMPLE );
    { close cluster but not have been accepted yet }
    elseif xtype = 4 & !CACCEPT then
      x = errmsg( 014, CSAMPLE );
    { close cluster but not have been passed by secondary editing }
    elseif xtype = 4 & !CEDIT(1) then
      x = errmsg( 017, CSAMPLE );
    endif;
    close( CONTROL );
    valstatus = ( x = 0 );
  end;

  { updates the control file after it is accepted, runs secondary editing or it is closed }
  function updtctrl( xtype )
  { xtype - 1 updates cluster accepted      }
  {         2 updates secondary editing     }
  {         3 cluster is declared as closed }
    open( CONTROL );
    CSAMPLE = WCLUSTER;
    if !loadcase( CONTROL, CSAMPLE ) then
      errmsg( 007, CSAMPLE );
    elseif xtype = 1 then                      { update cluster accepted date }
      CACCEPT = sysdate( "YYYYMMDD" );
      writecase( CONTROL );
    elseif xtype = 2 then                      { update inconsistencies }
      do i = 1 while i <= 5
        if CEDIT(i) = 0 then
          CEDIT(i) = sysdate( "YYYYMMDD" );
          writecase( CONTROL );
          break;
        endif;
      enddo;
    elseif xtype = 3 then                      { update close cluster }
      if CACCEPT = 0 then
        errmsg( 014, CSAMPLE );
      elseif CEDIT(1) = 0 then
        errmsg( 017, CSAMPLE );
      elseif CFINDATE <> 0 then
        errmsg( 008, CSAMPLE );
      else
        CFINDATE = sysdate( "YYYYMMDD" );
        writecase( CONTROL );
        errmsg( 080, CSAMPLE );
      endif;
    endif;
    close( CONTROL );
  end;

  { writes pif files headings }
  function InitPFF( CSmod );
    setfile( piffile, central + "\" + AppName + ".pff", create );
    FileWrite( piffile, "[Run Information]" );
    FileWrite( piffile, "Version=CSPro 7.3" );
    FileWrite( piffile, "AppType=" + executable(csmod) );
  end;

  { generates the PFF file needed to run AppNamelication LSTCLSUT.  This AppNamelication  }
  { is a modified version of CHECKID to check for structural problems in the      }
  { cluster as well as to update the control file                                 }
  function LstClust( whatdir )
  { whatdir - 1 to list and check clusters from arrived directory }
  {           2 to check clusters from CLOSED directory           }
    InitPFF(1);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + central + "\" + AppName + ".bch" );
    if whatdir = 1 then
      FileWrite( piffile, "InputData=" + arrived + "\H" + xcluster + ".dat" );
    elseif whatdir = 2 then
      FileWrite( piffile, "InputData=" + closed  + "\H" + xcluster + ".dat" );
    endif;
    FileWrite( piffile, "Listing=" +   central + "\" + AppName + ".lst" );
    FileWrite( piffile, "WriteData=" + central + "\" + AppName + ".wrt" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "CONTSUP=" + wrkref + "\Superv" + edit("9999", WSUPER) + ".dat" );
    FileWrite( piffile, "CONTROL=" + wrkref + "\Control.dat" );
    FileWrite( piffile, "INTERV="  + wrkref + "\Interv.dat" );
    if whatdir = 1 then       { data after unzipping from field }
      FileWrite( piffile, "ccIN80=" + arrived + "\I" + xcluster + ".dat" );
    elseif whatdir = 2 then   { data after accepting from field }
      FileWrite( piffile, "ccIN80=" + closed  + "\I" + xcluster + ".dat" );
    endif;
    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + edit("9", (whatdir = 1)) );  { 1-first time, 0-listing cluster }
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    FileWrite( piffile, "ListingWidth=120" );
    close( piffile );
  end;

  { constructs PPF file to sort the control file by supervisor (SORTCONT) }
  function SortCont()
    InitPFF(3);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + central + "\" + AppName + ".ssf" );
    FileWrite( piffile, "InputData="   + wrkref  + "\Control.dat" );
    FileWrite( piffile, "OutputData="  + wrkref  + "\ContSort.dat" );
    FileWrite( piffile, "Listing="     + central + "\" + AppName + ".lst" );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { constructs PPF file to sort household or individual data   }
  { sorting data is specially important for women in order to  }
  { check that children are not declared by more than one      }
  { woman in the same household                                         }
  function SortData( xtype )
  { xtype - 1 to sort household data }
  {         2 to sort women's data   }
    InitPFF(3);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile,   "Application=" + central + "\"  + AppName  + ".ssf" );
    if xtype = 1 then
      FileWrite( piffile, "InputData="   + arrived + "\H" + xcluster + ".dat" );
      FileWrite( piffile, "OutputData="  + closed  + "\H" + xcluster + ".dat" );
    elseif xtype = 2 then
      FileWrite( piffile, "InputData="   + arrived + "\I" + xcluster + ".dat" );
      FileWrite( piffile, "OutputData="  + closed  + "\I" + xcluster + ".dat" );
    endif;
    FileWrite( piffile,   "Listing="     + central + "\"  + AppName  + ".lst" );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { generates the PFF file for the data collection status report Application }
  function StatRep( whatfile )
    InitPFF(1);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + central + "\" + AppName + ".bch" );
    if whatfile = 1 then
      FileWrite( piffile, "InputData=" + wrkref  + "\Control.dat" );
    else
      FileWrite( piffile, "InputData=" + wrkref  + "\ContSort.dat" );
    endif;
    FileWrite( piffile, "Listing="     + central + "\" + AppName + ".lst" );
    FileWrite( piffile, "WriteData="   + reports + "\" + AppName + ".wrt" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "INTERV=" + wrkref + "\Interv.dat" );
    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { generates the PFF file check field tables }
  function FieldChk()
    InitPFF(1);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + central + "\" + AppName + ".bch" );
    FileWrite( piffile, "InputData="   + reports + "\AllHH80.dat" );
    FileWrite( piffile, "Listing="     + central + "\" + AppName + ".lst" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "ccIN80="      + reports + "\AllIN80.dat" );
    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=T" );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { generates the PFF file for the household secondary edit AppNamelication }
  function HHedit8()
    InitPFF(1);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + central + "\"  + AppName  + ".bch" );
    FileWrite( piffile, "InputData="   + closed  + "\H" + xcluster + ".dat" );
    FileWrite( piffile, "Listing="     + central + "\"  + AppName  + ".lst" );
    FileWrite( piffile, "WriteData="   + central + "\"  + AppName  + ".wrt" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "TRANSMIT="    + wrkref  + "\TransmitH" + edit("9999",WSUPER) + ".dat" );
    FileWrite( piffile, "FIELDWKQ="    + wrkref  + "\FieldWork.dat" );
    FileWrite( piffile, "CLUSTERS="    + wrkref  + "\Clusters.dat" );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "ViewListing=Never" );
    FileWrite( piffile, "ViewResults=No" );
    FileWrite( piffile, "ListingWidth=120" );
    close( piffile );
  end;

  { generates the PFF file for the individual secondary edit AppNamelication }
  function INedit8()
    InitPFF(1);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + central + "\"  + AppName  + ".bch" );
    FileWrite( piffile, "InputData="   + closed  + "\I" + xcluster + ".dat" );
    FileWrite( piffile, "Listing="     + central + "\"  + AppName  + ".lst" );
    FileWrite( piffile, "WriteData="   + central + "\"  + AppName  + ".wrt" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "ccHH80="     + closed  + "\H"  + xcluster + ".dat" );
    FileWrite( piffile, "FIELDWKQ="   + wrkref  + "\FieldWork.dat" );
    FileWrite( piffile, "CLUSTERS="    + wrkref  + "\Clusters.dat" );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "ViewListing=Never" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "ViewResults=No" );
    FileWrite( piffile, "ListingWidth=120" );
    close( piffile );
  end;

  { constructs PPF file for household and individual data entry }
  function genpff( questype )
    InitPFF(2);
    FileWrite( piffile, "[DataEntryInit]" );
    FileWrite( piffile, "OperatorID=" + opid );
    FileWrite( piffile, "Lock=Add, Verify" );
    FileWrite( piffile, "Fullscreen=No" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );
    { TEMP directory where data is stored, set before executing the option }
    if questype = 1 then
      FileWrite( piffile, "InputData=" + temp  + "\H" + xcluster + ".dat" );
    elseif questype = 2 then
      FileWrite( piffile, "InputData=" + temp  + "\I" + xcluster + ".dat" );
    endif;
    FileWrite( piffile, "Listing="     + temp  + "\"  + AppName + ".lst" );

    FileWrite( piffile, "[ExternalFiles]" );
    if questype = 1 then
      FileWrite( piffile, "ccIN80"    + temp   + "\I" + xcluster + ".dat" );
      FileWrite( piffile, "HHFORINT=" + wrkref + "\Snull.dat" );
      FileWrite( piffile, "FIELDWKQ=" + wrkref + "\FieldWork.dat" );
    else
      FileWrite( piffile, "ccHH80="   + temp   + "\H" + xcluster + ".dat" );
    endif;
    FileWrite( piffile, "OTHERS="     + temp   + "\O" + xcluster + ".dat" );
    FileWrite( piffile, "CLUSTERS="   + wrkref + "\Clusters.dat" );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    { customize parameters for different types of data entry modes }
    xparamet[9:1]  = "1";                    { Modify by central office }
    xparamet[11:1] = "1";                    { to run modify mode }
    FileWrite( piffile, "Parameter=" + xparamet );
    close( piffile );
  end;

  { prepares files to view later with ListView }
  function PrepFiles( string file1, string file2, string file3, copyto )
    { Using single quotes instead of double quotes as double quotes are needed in the string generated }
	if FileExist(file2) & !FileEmpty(file2) then
      if copyto = 1 then
        FileConcat( reports + "\" + file3,     { destination }
                   central + "\" + file1,     { file 1 to concatenate }
                   central + "\" + file2 );   { file 2 to concatenate }
      else
        FileConcat( central + "\" + file3,     { destination }
                   central + "\" + file1,     { file 1 to concatenate }
                   central + "\" + file2 );   { file 2 to concatenate }
      endif;
	else
      FileCopy( central + "\" + file1, central + "\" + file3 );
	endif;
  end;

  { check that files for households and individuala exist in a given directory }
  function files_in( string directory )
    exist = 0;
    if FileExist( directory + "\H" + xcluster + ".dat" ) &
       FileExist( directory + "\I" + xcluster + ".dat" ) then
      exist = 1;
    endif;
    files_in = exist;
  end;

  { generates a list of nottes taken by interviewer in cluster }
  function ListNotes()
    InitPff( 2 );
    FileWrite( piffile, "[DataEntryInit]" );
    FileWrite( piffile, "OperatorID=Anyone" );
    FileWrite( piffile, "Lock=Add, Verify" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    { Files section }
    FileWrite( piffile, " " );
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );

    { External Files section }
    FileWrite( piffile, " " );
    FileWrite( piffile, "[UserFiles]" );
    FileWrite( piffile, "FILENOTE=" + arrived + "\N" + xcluster + ".csnot" );

    FileWrite( piffile, "[Parameters]" );
    { parameters are: cluster and household number (may include others for sub-samples) }
    FileWrite( piffile, "Language=" + GetLanguage() );
    FileWrite( piffile, "Parameter=" + xcluster + "2" );
    FileWrite( piffile, "ViewListing=Never" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { copy files from arrived directory to closed directory      }
  { to copy household and individual data it uses sort instead.}
  { Sorting data is specially important for women in order to  }
  { check that children are not declared by more than one      }
  { woman in the same household                                }
  function copyfinal()
    { sorts household data and outputs it to directory CLOSED }
    AppName = "SortHH";
    sortdata( 1 );
    runpff();
    { sorts individual data and outputs it to directory CLOSED }
    AppName = "SortIN";
    sortdata( 2 );
    runpff();
    { copy others }
    FileCopy( arrived + "\O" + xcluster + ".dat", closed );         { others }
    FileCopy( arrived + "\T" + xcluster + ".dat.csnot", closed );   { notes }
  end;

  { check a version available for the next back-up. It is a Round-robin system made of up to 10 versions  }
  function backupn()
    numeric n;
    do n = 0 while n <= 9 & FileExist( backup + "\" + dirbkp + "_" + edit("9",n) + ".zip" )
    enddo;
    { open space for next back-up }
    x = n + 1;
    if n = 9 then x = 0 endif;
    fname = backup + "\" + dirbkp + "_" + edit("9",x) + ".zip";
    if FileExist( fname ) then
      FileDelete( fname );
    endif;
    backupn = n;
  end;

  { finds the drive letter where the flash memory is located }
  function searchdrive()
    numeric found = 0;
    do i = 1 while i <= 5 & !found
      backup = "DEFGH"[i:1] + ":\" + dirbkp;
      if DirExist( backup ) then
        found = 1;
      endif;
    enddo;
    searchdrive = found;
  end;

  { back-ups data to hard drive and memory flash }
  function backupf()
    numeric nextbkp;
    { back-up arrived and closed directories }
    do j = 1 while j <= 2
      dirbkp  = "Arrived" ;
      if j = 2 then dirbkp = "Closed" endif;
      if !searchdrive() | !DirExist( backup ) then
        errmsg( 070, backup );
        searchdrive();
      endif;
      if DirExist( backup ) then
        { handle round robin back-up number }
        nextbkp = backupn();
        TheCommand = Utility + "\UpgradePc\7za.exe a -w" + work + " -i!" + wrkpii +  "\" + dirbkp + "\*.* " +
                    backup  + "\" + dirbkp + "_" + edit("9",nextbkp) + ".zip";
        ExecSystem( TheCommand, maximized, wait );
        errmsg( 072, dirbkp, backup );
      else
        errmsg( 071, backup );
        break;
      endif;
    enddo;
  end;

  { collapse all households into one file }
  function collapsehh()
    FileConcat( reports + "\AllHH80.dat",      { destination }
               arrived + "\H????.dat" );       { from }
  end;

  { collapse all individuals into one file }
  function collapsein()
    FileConcat( reports + "\AllIN80.dat",      { destination }
               arrived + "\I????.dat" );       { from }
  end;
  
  { get the supervisor that corresponds to an interviewer } 
  function GetSuperv( zinterv )
    numeric zsuperv = 0, zteam = 0, found = 0, k, l;
	zsupname = "";
    do k = 1 while k <= totintvw & !found
	  if zinterv = intvwcode(k) then
	    zteam = intvwteam(k);
		do l = 1 while l <= totintvw & !found
		  if intvwteam(l) = zteam & intvwrole(l) = 2 then
		    zsuperv  = intvwcode(l);
			zsupname = intvwname(l);
			found = 1;
		  endif;
		enddo;
      endif;
	enddo;
	GetSuperv = zsuperv;
  end;

  { update clusters arrived from the field from directory Receive in supervisor machine }
  function UpdateControlArrived()
    numeric firstfile = 1, xinterv;
	string  xdatebeg;
	NewClusters.clear();
	DirList( NewClusters, work, "H????????.dat" );
    do i = 1 while i <= NewClusters.length()
	  do j = length(NewClusters(i)) while NewClusters(i)[j:1] <> "\" by (-1) enddo;
      CSAMPLE = tonumber( NewClusters(i)[j+2:4] );
      xinterv = tonumber( NewClusters(i)[j+6:4] );
      if loadcase(CONTROL, CSAMPLE) & !CDATEBEG then
        CDATEBEG = sysdate("YYYYMMDD", FileTime(NewClusters(i)));
		xdatebeg = edit( "9999/99/99", CDATEBEG );
		CSUPERV  = GetSuperv( xinterv );
        writecase( CONTROL );
		if firstfile then
          HTML_Paragraph( " " );
          HTML_ParagraphS( tr("Clusters that arrived for the first time to the central office") );
		  firstfile = 0;
		endif;
		zstring2 = tr("Cluster:") + " %04d " + tr("Created on:") + " %s " + tr("Supervisor:") + " %s";
		zstring2 = maketext( zstring2, CSAMPLE, xdatebeg, zsupname );  
        HTML_Paragraph( zstring2 );
      endif;
    enddo;
    UpdateControlArrived = (firstfile = 0);
  end;

  { find closed clusters in the field that arrived to the central office }
  function FindClosedClusters()
    numeric newdate = 0, NewTime = 0, firstfile = 1;
    string strtail, DateStr, TimeStr; 
	NewClusters.clear();
	DirList( NewClusters, arrived, "H????.dat" );
    do i = 1 while i <= NewClusters.length()
      NewDate = sysdate("YYYYMMDD", FileTime(NewClusters(i)));
	  DateStr = edit("9999/99/99", NewDate);
      NewTime = systime("HHMMSS", FileTime(NewClusters(i)));
	  TimeStr = edit("99:99:99", NewTime);
	  do j = length(NewClusters(i)) while NewClusters(i)[j:1] <> "\" by (-1) enddo;
      CSAMPLE = tonumber( NewClusters(i)[j+2:4] );
      if loadcase(CONTROL, CSAMPLE) & (!CACCEPT | newdate > CACCEPT) then
        if firstfile then
          HTML_Paragraph( " " );
          HTML_ParagraphS( tr("Completed clusters to be accepted: 1-Arrived first time; 2-Already accepted; 3-Passed secondary editing") );
		  firstfile = 0;
		endif;
        strtail = " ";
        if CFINDATE then
          strtail = tr("but already accepted and passed secondary editing on:") + " " + edit("9999/99/99",CFINDATE);
        elseif CACCEPT then
          strtail = tr("but was already accepted on:") + " " + edit("9999/99/99",CACCEPT);
        elseif !CACCEPT then
          strtail = tr("arrived for the first time");
        endif;
		zstring2 = tr("Cluster:") + " %04d " + tr("arrived on:") + " %s-%s %s"; 
		zstring2 = maketext( zstring2, CSAMPLE, datestr, timestr, strtail ); 
        HTML_Paragraph( zstring2 );
      endif;
      FindClosedClusters = (firstfile = 0)
    enddo;
  end;

PROC FL_MENU
PreProc

  CSPro  = PathName( CSPro );
  setfont( ValueSets, "Arial", 24, bold );
  
  backup = "E:";                         { needs directories: ARRIVED and CLOSED, function searchdrive() will change it if necessary }

  { Operator ID }
  opid="Anyone";                         { this could be an ID set on each machine }

  { set up minimal user bar }
  userbase();
  userbar( show );
  { set the language at the start of the program, defaulting to English }
  setlanguage(loadsetting("Language", "EN"));

  wrkprj  = "C:\cc81";
  wrkpii  = wrkprj + "\Pii";      { subdirecory to store data with PII }
  entry   = wrkprj + "\Entry";    { data entry programs }
  superv  = wrkprj + "\Superv";   { supervisor programs }
  central = wrkprj + "\Central";  { central office programs }
  utility = wrkprj + "\Utility";  { directory where auxiliary utilities are stored }
  reports = wrkpii + "\Reports";  { to store all reports }
  wrkref  = wrkpii + "\Ref";      { reference directory for clusters, sample and teams files }
  arrived = wrkpii + "\Arrived";  { stores closed clusters sent from supervisors by IFSS }
  closed  = wrkpii + "\Closed";   { to store final files after being accepted }
  work    = wrkpii + "\Work";     { store temporary data sent by IFSS from supersvisors to be used for check field tables }

  setfile( fromckid, central + "\Errors.txt" );  { file coming from LSTCLUST }

  { set the name for the HTML file }
  HTML_InitAlign();
  HTMLname = "FromField.html";
  if FileExist( HTMLname ) then
    FileDelete( HTMLname )
  endif;
  setfile( HTMLFile, HTMLname, create );
  { initialize the report headings }
  zstring1 = tr("Clusters arrived from the field since last time the central office system was executed");
  HTML_Header( CellAlign, zstring1 );  // generates a general HTML header

PostProc
  {PostProc of level 0 }
  stop(1);

PROC MENU_LEVEL
PreProc

  set attributes( MENU_DICT ) assisted off (variable (title));
  
  { load file of interviewers into memory }
  open( INTERV );
  do j = 1 while loadcase( INTERV )     
    intvwcode(j) = ICODE;
    intvwteam(j) = ITEAM;
    intvwname(j) = INAME;
    intvwrole(j) = IROLE;
  enddo;
  totintvw = j-1;
  close( INTERV );

  { update control file with clusters arrived from the field }
  numeric NewClust = UpdateControlArrived();
  numeric ClsClust = FindClosedClusters();
  HTML_End();
  if NewClust | ClsClust then
    view( HTMLname );
  endif;

PROC WINTRO
preproc
  skip to WSUPER;

PROC WSUPER
onfocus
  fieldworkers.clear();
  do j = 1 while j <= totintvw
    if intvwrole(j) = 2 then            { supervisor }
      fieldworkers.add( intvwname(j), intvwcode(j) );
    endif;
  enddo;
  SetValueSet( $, fieldworkers );
  
  $ = tonumber( loadsetting("Supervisor") );
  
postproc
  SaveSetting( "Supervisor", edit("9999",$) );
  do j = 1 while j <= totintvw & intvwcode(j) <> $ enddo;
  if j <= totintvw then
    steam = intvwteam(j);
    sname = intvwname(j);
  else
    errmsg( 023 );
  endif;

  skip to WCLUSTER;

PROC WCLUSTER
onfocus
  $ = tonumber( loadsetting("Cluster") );

postproc
  if !loadcase( CLUSTERS, $ ) then
    errmsg( 001, WCLUSTER );
    reenter;
  endif;
  SaveSetting( "Cluster", edit("9999",$) );

  WURBRUR    = GetLabel( YURBRUR, YURBRUR );
  WREGIONN   = YREGIONN;
  WSTATEN    = YSTATEN;
  WDISTRICTN = YDISTRICTN;
  WCITYN     = YCITYN;

  xcluster = edit( "9999", WCLUSTER );                 { Cluster number }
  xsupnum  = edit( "9999", WSUPER );                   { Supervisor }

  xparamet = "0000000000000000000";                    { initialize data entry parameter to zeros }
  { xparamet postions as received by the data collection AppNamelications }
  {  1:4   - interviewer number                                 }
  {  5:4   - supervisor number                                  }
  {  9:1   - modify by central office, also used by supervisors }
  { 10:1   - revisit                                            }
  { 11:1   - modify completed                                   }
  { 12:1   - if case has been saved partially                   }
  { 13:1   - enter height & weight data                         }
  { 14:4   - household number                                   }
  { 18:2   - individual's line number                           }

PROC WFINAL
  if getlanguage() = "EN" then
    heading = maketext( "Central Office Menu, Cluster: %s Supervisor: %04d-%s", xcluster, WSUPER, GetValueLabel(WSUPER) );
    action = accept( heading,
                { 1} "1 Accept Cluster                    ",
                { 2} "2 List questionnaires accepted      ",
                { 3} "3 Modify household questionnaire    ",
                { 4} "4 Modify individual questionnaire   ",
                { 5} "5 View notes for Cluster            ",
                { 6} "6 Run secondary editing for Cluster ",
                { 7} "7 Data collection status report     ",
                { 8} "8 Run quality control tables        ",
                { 9} "9 Close Cluster                     ",
                {10} "C Change number of Cluster          ",
                {11} "B Make a data back-up               ",
                {12} "X Exit (Esc)                        " );
  elseif getlanguage() = "ES" then
    heading = maketext( "Menu para Oficina Central, Segmento: %s Supervisor: %04d-%s", xcluster, WSUPER, GetValueLabel(WSUPER) );
    action = accept( heading,
                { 1} "1 Aceptar Segmento",
                { 2} "2 Listar cuestionarios aceptados",
                { 3} "3 Modificar Archivo de Hogar",
                { 4} "4 Modificar Archivo de Individuales",
                { 5} "5 Revisar notas del Segmento",
                { 6} "6 Correr Programa de Inconsistencias",
                { 7} "7 Listado de Avance de la Recoleccion",
                { 8} "8 Tablas de Control de Calidad",
                { 9} "9 Cerrar el Segmento",
                {10} "C Cambiar numero de Segmento",
                {11} "B Hacer copia de respaldo de los datos",
                {12} "X Salir del sistema (o use ESC)" );
  endif;
  if !action | action = 12 then stop(1) endif;

  if action = 10 then          { change cluster number }
    reenter WCLUSTER

  elseif action = 1 then       { receive cluster coming form supervisor }
    if files_in( arrived ) then
      if clustopen() then
        close( fromckid );     { it is necessary because LSTCLUST will generate it again }
        AppName = "LstClust";
        LstClust( 1 );
        runpff();
        FileRead( fromckid, chkfile );
        if pos( "WITH ERRORS", chkfile ) then
          errmsg( 103 );
        else
          copyfinal();
          updtctrl( 1 );                     { update control to accept cluster }
          errmsg( 115 );
        endif
      endif
    else
      errmsg( 102 );
    endif;
    reenter WFINAL;

  elseif action = 2 then       { list questionnaires for a cluster }
    if files_in( closed ) then
      close( fromckid );       { it is necessary because LSTCLUST will generate it again }
      close( CONTROL );
      AppName = "LstClust";
      LstClust( 2 );
      runpff();
      open( CONTROL );
    else
      errmsg( 104 );
    endif;
    reenter WFINAL;

  elseif action in 3:4 then                  { modify household/individual questionnaires }
    x = accept( tr("Data directory to be modified"), 
	            tr("1-To fix structural problems"), 
				tr("2-For secondary editing"),
				tr("3-Browse data"),
				tr("9-Return to main menu") );
    if x = 9 then
      reenter WFINAL
    endif;	  
    temp = Arrived;
    if x in 2,3 then temp = Closed endif;
    y = 1;
    { to check if cluster closed for both type of modifications or       }
    { already accepted or run secondary editing when structural problems }
    if x = 1 & !valstatus( x ) then
      y = accept( tr("Do you want to modify the original data anyway"), tr("Yes"), tr("No") );
    endif;
    if y = 1 & files_in( temp ) then
      if action = 3 then
        AppName = "CollectHH";
        genpff( 1 );
        runpff();
      elseif action = 4 then
        AppName = "CollectIN";
        genpff( 2 );
        runpff();
      endif;
    elseif y = 1 then
      errmsg( 105, temp );
    endif;
    reenter WFINAL;

  elseif action = 5 then                  { review notes for a cluster }
    if FileExist( arrived + "\N" + xcluster + ".csnot" ) then
      AppName = "ListNotes";
      ListNotes();
      runpff();
    else
      errmsg( 106, arrived );
    endif;
    reenter WFINAL;

  elseif action = 6 then                  { run inconsistencies }
    if files_in( closed ) then
      AppName = "HHEdit8";                     { first household }
      HHedit8();
      runpff();
      AppName = "INEdit8";                     { then for all individuals in the household }
      INedit8();
      runpff();
      PrepFiles( "HHEdit8.lst", "HHEdit8.wrt", "HHEdit8.rep", 2 );
      PrepFiles( "INEdit8.lst", "INEdit8.wrt", "INEdit8.rep", 2 );
      PrepFiles( "HHEdit8.rep", "INEdit8.rep", "S" + xcluster + ".rep", 1 );
      textview( reports, "S" + xcluster + ".rep" );
      updtctrl( 2 );                        { update control file with secondary editing runs }
    else
      errmsg( 107, closed );
    endif;
    reenter WFINAL;

  elseif action = 7 then                  { status report }
    filerep = accept( tr("Type of report desired"), tr("By Cluster"), tr("By Supervisor") );
	close( CONTROL );
    if filerep = 2 then
      AppName = "SortCont";
      sortcont();
      runpff();
    endif;
    AppName = "StatRep";
    statrep( filerep );
    runpff();
    view( AppName + ".html" );
	open( CONTROL );
    reenter WFINAL;

  elseif action = 8 then                 { run check field tables }
    collapsehh();
    collapsein();
    AppName = "FldCk7";
    FieldChk();
    runpff();
    reenter WFINAL;

  elseif action = 9 then                 { close cluster }
    if valstatus( 4 ) then
      updtctrl( 3 );                      { update control file after inconsistencies are run }
    endif;
    reenter WFINAL;

  elseif action = 11 then                { back-up data }
    backupf();
    reenter WFINAL;

  endif;

